---
layout: post
title:  "事务与隔离"
data: 星期日, 22. 三月 2020 04:24下午 
categories: 数据库
tags: 专题
---
* 该模块会针对数据库中的某一块知识做专题整理，也许会有些不足或者错误的地方，未来可能会作修改。

# 数据库专题4----mysql事务与隔离
事务是一个最小的不可分割的工作单元。事务能保证一个业务的完整性。


## 为什么要事务
简单举个例子，比如A要给B转100元，实际操作中是A先扣除100元，B再增加100元，两个过程。如果第一个过程执行完出了无法执行第二个过程会怎么办呢。事务就是为了解决这个问题。

## 四大特性（ACID）
#### 原子性（Atomicity）
要不全部成功，要不就全部不执行，或者全部失败回滚。

#### 一致性（Consistency）
一致性是指事务必须使数据库从一个一致性状态变换到另一个一致性状态，也就是说一个事务执行之前和执行之后都必须处于一致性状态。

　　拿转账来说，假设用户A和用户B两者的钱加起来一共是5000，那么不管A和B之间如何转账，转几次账，事务结束后两个用户的钱相加起来应该还得是5000，这就是事务的一致性。


#### 隔离性（Isolation）
隔离性是当多个用户并发访问数据库时，比如操作同一张表时，数据库为每一个用户开启的事务，不能被其他事务的操作所干扰，多个并发事务之间要相互隔离。


#### 持久性（Durability）
　持久性是指一个事务一旦被提交了，那么对数据库中的数据的改变就是永久性的，即便是在数据库系统遇到故障的情况下也不会丢失提交事务的操作。


> #### 一致性的四种方案
> **方案一：**
>
通过key的过期时间，mysql更新时，redis不更新。
>
**优点：**开发成本低，易于实现；管理成本低，出问题的概率会比较小。
>
**缺点：**完全依赖过期时间，时间太短容易缓存频繁失效，太长容易有长时间更新延迟（不一致）。

> **方案二：** 在方案一的基础上扩展，通过key的过期时间兜底，并且，在更新mysql时，同时更新redis。
>
**优点：**相对方案一，更新延迟更小。
>
**缺点：**1.如果更新mysql成功，更新redis却失败，就退化到了方案一；2.在高并发场景，业务server需要和mysql,redis同时进行连接。这样是损耗双倍的连接资源，容易造成连接数过多的问题。

> **方案三：**针对方案二的同步写redis进行优化，增加消息队列，将redis更新操作交给kafka，由消息队列保证可靠性，再搭建一个消费服务，来异步更新redis。
>
> **方案四：**通过订阅binlog来更新redis，把我们搭建的消费服务，作为mysql的一个slave，订阅binlog，解析出更新内容，再更新到redis。

>
参考链接：https://blog.csdn.net/wufaliang003/article/details/102381581

## 隔离级别

#### 如果没有隔离级别会产生的问题
**脏读：**脏读是指在一个事务处理过程里读取了另一个未提交的事务中的数据。
>
比如A事务修改C变量，改了一半但是A事务还没完成，B事务却把修改完的C给读走了。如果A回滚了就会出问题。

**不可重复读：**不可重复读是指在对于数据库中的某个数据，一个事务范围内多次查询却返回了不同的数据值，这是由于在查询间隔，被另一个事务修改并提交了。
>
比如说A事务刚开始读了C变量，B事务完成了，同时修改了C变量，A事务还没完又读了一次C变量，但是和第一次读的结果已经不一样了

**虚读(幻读):**在事务A多次读取构成中，事务B对数据进行了新增操作，导致事务A多次读取的数据和预想的不一样。

>
例如事务T1对一个表中所有的行的某个数据项做了从“1”修改为“2”的操作，这时事务T2又对这个表中插入了一行数据项，而这个数据项的数值还是为“1”并且提交给数据库。而操作事务T1的用户如果再查看刚刚修改的数据，会发现还有一行没有修改，其实这行是从事务T2中添加的，就好像产生幻觉一样，这就是发生了幻读。

**第一类丢失（回滚丢失） ：**比如A和B同时在执行一个数据，然后B事物已经提交了，然后A事物回滚了，这样B事物的操作就因A事物回滚而丢失了。上面三种问题都属于第一类丢失。

**第二类丢失:**A和B一起执行一个数据，两个同时取到一个数据，然后B事物首先提交，但是A事物加下来又提交，这样就覆盖了B事物，称为第二类事物丢失，覆盖丢失。

* MySQL默认级别是(Repeatable read)

在MySQL数据库中，支持下面四种隔离级别
#### 串行化/序列化(Serializable)(级别最高)
**隔离效果：**可避免脏读、不可重复读、幻读的发生。

事务在读取数据时，必须先对其加 表级共享锁 ，直到事务结束才释放；

事务在更新数据时，必须先对其加 表级排他锁 ，直到事务结束才释放。

#### 可重复读(Repeatable read)
**隔离效果：**可避免脏读、不可重复读的发生。

事务在读取某数据的瞬间（就是开始读取的瞬间），必须先对其加 行级共享锁，直到事务结束才释放；

事务在更新某数据的瞬间（就是发生更新的瞬间），必须先对其加 行级排他锁，直到事务结束才释放。

#### 读已提交(Read committed)
**隔离效果：**可避免脏读的发生，也避免第一类丢失的产生。

事务对当前被读取的数据加 行级共享锁（当读到时才加锁），一旦读完该行，立即释放该行级共享锁；

事务在更新某数据的瞬间（就是发生更新的瞬间），必须先对其加 行级排他锁，直到事务结束才释放。

#### 读未提交 (Read uncommitted)（级别最低）
**隔离效果：**最低级别，任何情况都无法保证。

事务在读数据的时候并未对数据加锁。

事务在修改数据的时候只对数据增加行级共享锁。

## 当前读与快照读
在mysql中，提供了两种事务隔离技术，第一个是mvcc，第二个是next-key技术，这个在使用不同的语句的时候可以动态选择。

innoDB默认的隔离就是使用MVCC技术实现的可重复读
#### 一致性非锁定读/快照读(snapshot read)


**快照读解决的问题：**读取的数据虽然是一致的，但是数据是历史数据，我们需要的是最新的数据。也就是一个事务，其内部读取对应某一个数据的时候，数据都是一样的。

**实现方式：**
InnoDB 通过 MVCC（多版本控制）**将数据库在过去某个时刻的快照应用在查询上**，使得这次查询**只能看到别的事务生成快照前提交的数据**，而不能看到 别的事务生成快照后提交的数据或者未提交的数据。

**不同隔离级别下的快照读：**
快照读是**repeatable-read和read-committed**级别下默认的查询模式。

READ COMMITTED 隔离级别下，**每次读取都会重新生成一个快照，所以每次快照都是最新的**，也因此事务中每次SELECT也可以看到其它已commit事务所作的更改。

REPEATED READ 隔离级别下，**快照会在事务中第一次SELECT语句执行时生成**，只有在本事务中对数据进行更改才会更新快照，因此，只有第一次SELECT之前其它已提交事务所作的更改你可以看到，但是如果已执行了SELECT，那么其它事务commit数据，你SELECT是看不到的。

**优点：**好处是：读不加锁，读写不冲突

**问题：**缺点是不是实时数据



* 只在简单的select操作(不包括 select ... lock in share mode, select ... for update)


#### 当前读(current read)

**实现方式：**
读取的是最新版本, 并且对**读取的记录加锁, 阻塞其他事务同时改动相同记录**，避免出现安全问题,具体来说就是**next-key锁(行记录锁+间隙锁)**
>
**间隙锁:**
>
只有在Read Repeatable、Serializable隔离级别才有，就是锁定范围空间的数据，假设id有3,4,5，锁定id>3的数据，是指的4，5及后面的数字都会被锁定，因为此时如果不锁定没有的数据，例如当加入了新的数据id=6，就会出现幻读，间隙锁避免了幻读。
>
注意并不是都会加间隙锁，分三种情况
>
1.对主键或唯一索引，如果当前读时，where条件**全部精确命中**(=或者in)，这种场景本身就不会出现幻读，所以只会加行记录锁。
>
2.没有索引的列，当前读操作时，会加全表间隙锁，生产环境要注意。
>
3.非唯一索引列，如果where条件部分命中(>、<、like等)或者全未命中，则会加附近间隙锁。例如，某表数据如下，非唯一索引2,6,9,9,11,15。如下语句要操作非唯一索引列9的数据，gap锁将会锁定的列是(6,11]，该区间内无法插入数据。
>
![](https://github.com/LLLibra/LLLibra.github.io/raw/master/_posts/imgs/20200417-164103.png)

**使用场景：**

select ... lock in share mode

select ... for update

insert

update

delete

**优点：**
获取实时数据

**缺点：**
需要加锁。


#### 可重复读的两种实现方式
使用基于MVCC的快照读不能避免幻读，但是基于next-key的可重复读是可以避免幻读的。













