---
layout: post
title:  "事务与隔离"
data: 星期日, 22. 三月 2020 04:24下午 
categories: 数据库
tags: 专题
---
* 该模块会针对数据库中的某一块知识做专题整理，也许会有些不足或者错误的地方，未来可能会作修改。

# 数据库专题4----mysql事务与隔离
事务是一个最小的不可分割的工作单元。事务能保证一个业务的完整性。


## 为什么要事务
简单举个例子，比如A要给B转100元，实际操作中是A先扣除100元，B再增加100元，两个过程。如果第一个过程执行完出了无法执行第二个过程会怎么办呢。事务就是为了解决这个问题。

## 四大特性（ACID）
#### 原子性（Atomicity）
要不全部成功，要不就全部不执行，或者全部失败回滚。

#### 一致性（Consistency）
一致性是指事务必须使数据库从一个一致性状态变换到另一个一致性状态，也就是说一个事务执行之前和执行之后都必须处于一致性状态。

　　拿转账来说，假设用户A和用户B两者的钱加起来一共是5000，那么不管A和B之间如何转账，转几次账，事务结束后两个用户的钱相加起来应该还得是5000，这就是事务的一致性。


#### 隔离性（Isolation）
隔离性是当多个用户并发访问数据库时，比如操作同一张表时，数据库为每一个用户开启的事务，不能被其他事务的操作所干扰，多个并发事务之间要相互隔离。


#### 持久性（Durability）
　持久性是指一个事务一旦被提交了，那么对数据库中的数据的改变就是永久性的，即便是在数据库系统遇到故障的情况下也不会丢失提交事务的操作。


## 隔离级别

#### 如果没有隔离级别会产生的问题
** 脏读： **脏读是指在一个事务处理过程里读取了另一个未提交的事务中的数据。
>
比如A事务修改C变量，改了一半但是A事务还没完成，B事务却把修改完的C给读走了。如果A回滚了就会出问题。

** 不可重复读：**不可重复读是指在对于数据库中的某个数据，一个事务范围内多次查询却返回了不同的数据值，这是由于在查询间隔，被另一个事务修改并提交了。
>
比如说A事务刚开始读了C变量，B事务完成了，同时修改了C变量，A事务还没完又读了一次C变量，但是和第一次读的结果已经不一样了

** 虚读(幻读): **在事务A多次读取构成中，事务B对数据进行了新增操作，导致事务A多次读取的数据和预想的不一样。

>
例如事务T1对一个表中所有的行的某个数据项做了从“1”修改为“2”的操作，这时事务T2又对这个表中插入了一行数据项，而这个数据项的数值还是为“1”并且提交给数据库。而操作事务T1的用户如果再查看刚刚修改的数据，会发现还有一行没有修改，其实这行是从事务T2中添加的，就好像产生幻觉一样，这就是发生了幻读。

** 第一类丢失（回滚丢失） ：** 比如A和B同时在执行一个数据，然后B事物已经提交了，然后A事物回滚了，这样B事物的操作就因A事物回滚而丢失了。上面三种问题都属于第一类丢失。

** 第二类丢失: **A和B一起执行一个数据，两个同时取到一个数据，然后B事物首先提交，但是A事物加下来又提交，这样就覆盖了B事物，称为第二类事物丢失，覆盖丢失。


在MySQL数据库中，支持下面四种隔离级别
#### 串行化/序列化(Serializable)(级别最高)
** 隔离效果： **可避免脏读、不可重复读、幻读的发生。

事务在读取数据时，必须先对其加 表级共享锁 ，直到事务结束才释放；

事务在更新数据时，必须先对其加 表级排他锁 ，直到事务结束才释放。

#### 可重复读(Repeatable read)
** 隔离效果： **可避免脏读、不可重复读的发生。

事务在读取某数据的瞬间（就是开始读取的瞬间），必须先对其加 行级共享锁，直到事务结束才释放；

事务在更新某数据的瞬间（就是发生更新的瞬间），必须先对其加 行级排他锁，直到事务结束才释放。

#### 读已提交(Read committed)
** 隔离效果： **可避免脏读的发生，也避免第一类丢失的产生。

事务对当前被读取的数据加 行级共享锁（当读到时才加锁），一旦读完该行，立即释放该行级共享锁；

事务在更新某数据的瞬间（就是发生更新的瞬间），必须先对其加 行级排他锁，直到事务结束才释放。

#### 读未提交 (Read uncommitted)（级别最低）
** 隔离效果： **最低级别，任何情况都无法保证。

事务在读数据的时候并未对数据加锁。

事务在修改数据的时候只对数据增加行级共享锁。




















