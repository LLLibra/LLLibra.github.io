---
layout: post
title:  "EffectiveSTL"
data: 星期三, 30. 九月 2020 09:23上午 
categories: C++
tags: 读书笔记
---
# Google C++ 编程规范
* 每个人写代码都有自己的风格，但是开发往往不是一个人的事，所以统一风格很重要，我所在的组一般采用google C++规范。特此开一篇博文记录一下。

## 头文件
####  头文件要自给自足
所有头文件要能够自给自足。换言之，用户和重构工具不需要为特别场合而包含额外的头文件。

#### #define保护
![](imgs/20200930-093438.png)

#### 前置声明
> 所谓「前置声明」（forward declaration）是类、函数和模板的纯粹声明，没伴随着其定义.

尽可能避免使用前置声明。使用#include包含所需要的头文件即可。

前置声明能减少编译时间，减少不必要的#include,避免#include使代码因为头文件无关的改动而被重新编译多次

**但是也有缺点**

1.前置声明隐藏了依赖关系，头文件改动时，用户的代码会跳过必要的重新编译过程

2.前置声明了不少来自头文件的symbol时，就会比单单一行的include冗长。

3.有的时候采用前置声明代替include甚至都会暗暗改变代码的含义

![](imgs/20200930-095835.png)

4.前置声明来自命名空间 std:: 的 symbol 时，其行为未定义。

5.前置声明可能会被库的后续更改所破坏。前置声明函数或模板有时会妨碍头文件开发者变动其 API. 例如扩大形参类型，加个自带默认参数的模板形参等等。

>前置声明的类是不完全类型（incomplete type），我们只能定义指向该类型的指针或引用，或者声明（但不能定义）以不完全类型作为参数或者返回类型的函数。毕竟编译器不知道不完全类型的定义，我们不能创建其类的任何对象，也不能声明成类内部的数据成员。
>所以当用到其他文件的类时但是不需要调用其实现方法，尽量只用指针，这样就可以直接使用前置声明了

#### #include的路径及顺序
1.项目内头文件应按照项目源代码目录树结构排列, 避免使用 UNIX 特殊的快捷目录 . (当前目录) 或 .. (上级目录). 

2.注意库的声明顺序

![](imgs/20200930-102209.png)

这种优先的顺序排序保证当 dir2/foo2.h 遗漏某些必要的库时， dir/foo.cc 或 dir/foo_test.cc 的构建会立刻中止。因此这一条规则保证维护这些文件的人们首先看到构建中止的消息而不是维护其他包的人们。

3.按字母顺序分别对每种类型的头文件进行二次排序是不错的主意。注意较老的代码可不符合这条规则，要在方便的时候改正它们。

4.您所依赖的符号被哪些头文件所定义，您就应该包含哪些头文件，前置声明情况除外。比如您要用到 bar.h 中的某个符号, 哪怕您所包含的 foo.h 已经包含了 bar.h, 也照样得包含 bar.h, 除非 foo.h 有明确说明它会自动向您提供 bar.h 中的 symbol. 

5.凡是 cc 文件所对应的「相关头文件」已经包含的，就不用再重复包含进其 cc 文件里面了，就像 foo.cc 只包含 foo.h 就够了，不用再管后者所包含的其它内容。

6.有时，平台特定（system-specific）代码需要条件编译（conditional includes），这些代码可以放到其它 includes 之后。当然，您的平台特定代码也要够简练且独立，比如：

![](imgs/20200930-102802.png)

## 作用域
鼓励在 .cc 文件内使用匿名命名空间或 static 声明. 使用具名的命名空间时, 其名称可基于项目名或相对路径. **禁止使用 using 指示（using-directive）。禁止使用内联命名空间（inline namespace）。**

> ![](imgs/20201003-103700.png)


命名空间将全局作用域细分为独立的, 具名的作用域, 可有效防止全局作用域的命名冲突.

**不要在命名空间 std 内声明任何东西**, 包括标准库的类前置声明. 在 std 命名空间声明实体是未定义的行为, 会导致如不可移植. 声明标准库下的实体, 需要包含对应的头文件.

**不应该使用 using 指示 引入整个命名空间的标识符号。会污染命名空间**

**不要在头文件中使用命名空间别名，除非显式标记内部命名空间使用。**因为任何在头文件中引入的命名空间都会成为公开API的一部分。

> 命名空间内不用包含 
> 1. include头文件 2. gflags 的声明/定义 3.类的前置声明


#### 局部变量
1.声明变量离变量第一次使用越近越好

2.应使用初始化的方式替代声明再赋值

* 有一个例外, 如果变量是一个对象, 每次进入作用域都要调用其构造函数, 每次退出作用域都要调用其析构函数. 这会导致效率降低. 具体例子就是不应该在for循环内部定义变量。

#### 静态和全局变量
POD变量：内置类型的变量

静态生存周期的对象: 全局变量，静态变量，静态类成员变量和函数静态变量

**禁止定义静态储存周期非POD变量，禁止使用含有副作用的函数初始化POD全局变量，因为多编译单元中的静态变量执行时的构造和析构顺序是未明确的，这将导致代码的不可移植。**

不过 constexpr 变量除外，毕竟它们又不涉及动态初始化或析构。

 >
同一个编译单元内是明确的，静态初始化优先于动态初始化，初始化顺序按照声明顺序进行，销毁则逆序。不同的编译单元之间初始化和销毁顺序属于未明确行为 (unspecified behaviour)。

**所以除了禁用类类型的全局变量，我们也不允许用函数返回值来初始化 POD 变量，除非该函数（比如 getenv() 或 getpid() ）不涉及任何全局变量。函数作用域里的静态变量除外，毕竟它的初始化顺序是有明确定义的，而且只会在指令执行到它的声明那里才会发生。**

**综上所述，我们只允许 POD 类型的静态变量，即完全禁用 vector (使用 C 数组替代) 和 string (使用 const char [])。**

如果您确实需要一个 class 类型的静态或全局变量，可以考虑在 main() 函数或 pthread_once() 内初始化一个指针且永不回收。**注意只能用 raw 指针，别用智能指针**，毕竟后者的析构函数涉及到上文指出的不定顺序问题。


### 额外笔记
1.在 #include 中插入空行以分割相关头文件, C 库, C++ 库, 其他库的 .h 和本项目内的 .h 是个好习惯。

2.类内部的函数一般会自动内联。所以某函数一旦不需要内联，其定义就不要再放在头文件里




























