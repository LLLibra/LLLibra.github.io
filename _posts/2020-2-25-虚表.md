---
layout: post
title:  "虚函数表"
data: 星期二, 25. 二月 2020 10:25上午 
categories: C++
tags: 专题
---
* 该模块会针对C++中的某一块知识做专题整理，也许会有些不足或者错误的地方，未来可能会作修改。

# C++专题7----虚函数表

* 探究虚函数更深层的原理

## 前言

1.虚函数（Virtual Function）是通过一张虚函数表（Virtual Table）来实现的，简称为V-Table。通过类中的虚表指针_vfptr来找到对应的虚函数。一个类共享虚表，但是每个对象都有自己的虚表指针。

2.表中主是要一个类的虚函数的地址表，这张表解决了继承、覆盖的问题，保证其容真实反应实际的函数。当我们用父类的指针来操作一个子类的时候，这张虚函数表就显得由为重要了，它就像一个地图一样，指明了实际所应该调用的函数。

3.同一个类的不同实例共用同一份虚函数表, 她们都通过一个所谓的虚函数表指针__vfptr(定义为void**类型)指向该虚函数表.在单继承中（非虚继承），派生类会产生一个新的虚表，新的虚表指针，虽然内容是继承基类，但是独立于基类，内容可能与基类不同。

4.不含虚函数的类A和含一个虚函数的类B相比（即有一个函数在A中实现是非虚，在B中却是虚函数），即使其他内容完全相同，但是后者会多4字节，因为多了一个指针_vfptr,指向一个函数地址数组（虚函数表），数组中保存所有虚函数的地址。派生类会继承基类函数指针数组里的元素，如果派生类有重写，那么重写后的函数地址会覆盖函数指针数组里的函数地址。调用函数时会去虚函数表中找函数。（注意这时我们为B类中再添加一个虚函数，B类的大小即sizeof(B)并不会发生变化，只是在虚函数表中添加一项。）


5.在C++的标准规格说明书中说到，编译器必需要保证虚函数表的指针存在于对象实例中最前面的位置，**这意味着我们通过对象实例的地址得到这张虚函数表，然后就可以遍历其中函数指针，并调用相应的函数。**

6.虚表指针是在调用构造函数初始化的，**虚表存放于数据段（静态区或全局区）**，不能存放于栈和堆。

7.调用虚函数时，程序将查看存储在对象中的虚函数表地址，转向相应的虚函数表，使用类声明中定义的第几个虚函数，程序就使用数组的第几个函数地址，并执行该函数。

8.虚函数表在编译期就确定了

## 单继承中的虚函数表

#### 派生类不定义新的虚函数

![](https://github.com/LLLibra/LLLibra.github.io/raw/master/_posts/imgs/20200225-134217.png)

**内存偏移情况：**

基类：

![](https://github.com/LLLibra/LLLibra.github.io/raw/master/_posts/imgs/20200225-141833.png)

派生类：

![](https://github.com/LLLibra/LLLibra.github.io/raw/master/_posts/imgs/20200225-141804.png)

这是最简单的情况

![](https://github.com/LLLibra/LLLibra.github.io/raw/master/_posts/imgs/20200225-134247.png)

当然如果这里派生类对基类的虚函数进行了重写，那么派生类的虚表中的地址就会改变

![](https://github.com/LLLibra/LLLibra.github.io/raw/master/_posts/imgs/20200225-134551.png)

#### 派生类会定义新的虚函数
直接给结论，派生类的内存偏移不会发生变化，条目数和数字都不会变。原因在于派生类会直接把虚函数添加到继承而来的虚表中。就和我们在基类中添加虚函数但是基类的大小不会改变一样。

![](https://github.com/LLLibra/LLLibra.github.io/raw/master/_posts/imgs/20200225-142859.png)

我前面所说的正是这个图的左半部分，并不会变。

## 多继承中的虚函数表
按照基类的声明顺序，基类的成员依次分布在继承中。

![](https://github.com/LLLibra/LLLibra.github.io/raw/master/_posts/imgs/20200225-113847.png)

这里注意Derive类有两个基类Base1和Base2。d1是Derive的一个对象。
先讲讲几个原则：

1.如果Derive类有新的虚函数（基类中没有的虚函数），那么按照继承顺序找到第一个基类，插入到对应的虚表中（前提是有基类有虚表），如上例我们会将虚函数插入到Base1的虚表后面。(注意这个虚表是Derive类两个虚表中的一个,修改它并不会影响到原Base1中的虚表)

2.如果所有基类都没有虚函数，也就是没有虚表，那么派生类就自己创一个_vfptr指针放在所有基类后面。

3.在派生类中基类存储的优先顺序（继承顺序），首先看是否是虚继承（虚继承则排最后），再看有无虚函数(有虚函数优先)，再看声明顺序。如果再加一个基类为Base3,声明顺序为Base1,Base2,Base3,但是只有Base2没有基类，所以内存顺序是Base1,Base3,Base2，有虚函数就加入Base1部分中的虚表。

## 虚继承中的虚函数表

如果是虚继承，那么子类会有两份虚指针，一份指向自己的虚表，另一份指向虚基表，

虚基类派生出来的类中,虚基类的对象不在固定位置(应该是在尾部),需要一个中介才能访问虚基类的对象.所以子类需要有一个vbptr,对应的table中需要有一项指向虚基类.

虚基类表存储的是，虚基类相对直接继承类(派生类)的偏移。

指向虚基表的指针为vbptr（不占用类对象的存储空间） 

#### 单虚继承

1.如果派生类不添加虚函数，派生类会有两份虚指针，一份指向继承来的的虚表，另一份指向虚基表。

2.派生类如果添加新的虚函数，派生类会新增一个虚指针和虚表而不是添加到基类的虚表当中，所以类的大小会进一步增加。（不同于正常继承时添加新的虚函数并不增加类的大小）


#### 多重虚继承

**当基类全为虚继承：**

1.新添虚函数仍需要新开虚表和虚函数指针。

2.虚基表和虚基表指针只会有一个。

**当基类中有虚继承也有普通继承：**
待补充

#### 菱形继承
假设B和C虚继承A，D普通多重继承B和C。

那么D中会有B的两个指针，一个指向B的虚表一个指向B的虚基表

D中会有C的两个指针，一个指向C的虚表一个指向C的虚基表

D中会有A的指针，指向A的虚表

D中新添的虚函数会加到B的虚表中，并不会新增虚表

#### 虚继承的意义
如果B和C普通继承A   D能靠D.B:: 和D.C::访问B和C成员

而如果B和C虚继承A   D除了能靠D.B:: 和D.C::访问B和C成员 还能靠D.A::访问A的成员

**作用一：节约代码**
> 
这里面的区别就是D能否访问A的成员，如过BC是有一些东西都是一样的、基础的、不需要重写的，那么就可以用虚继承保证这些不需要被重写的东西可以通过D直接去A中访问到，不需要在B和C中都再保存一份，单单B保存就够了，而且即使A中的数据被B和C重写了也能访问了最原始的A的数据（虽然这条没什么用）。

**作用二：防止混淆**
>
对于继承体系中，如果B继承了A，C继承了B，即使C重写了B和A中的成员，C也可以通过C.A::和C.B::访问未重写的成员，所以大家对于如何访问祖父的数据有了认识，但是C++对于是谁的祖父是分不出的，假设C又继承了D，同时D继承了A，这时C.A::就会发生错误，因为系统发现C继承的B里有A的数据，D里也有A的数据，无法区分（就是这么笨），但是如果B和D对于A的继承是虚继承，那么C继承D的数据时就不会再有A的代码，和作用一呼应(具体的机制暂时未研究)，这时A就只有一个了，就可以使用C.A::。

## 虚继承修正

1.只要是虚继承，派生类就会有一个vptr指针，即使虚基类和派生类都没有虚函数，但是如果基类和派生类没有虚函数，那么派生类的vptr指针就是VTT表而不是Vtable，如果有虚函数那就是Vtable。（VTT表到底是啥）VTT表只能有一张，其余的vptr指针将全指向虚表，即使一个虚函数也没有。

2.当A类有虚基类，即使A作为基类继续继承，A中的vptr指针仍会存在。

3.虚表和虚基表合在一起了，指针也合成一个了，虚表指针即为虚基类指针，只有一个虚基类表可以理解为虚基类表的内容只会存在本类使用的虚表中。（本类使用的虚表即为如果添加新的虚函数会修改的虚表。）

5.虚表指针的地址等于类的地址，因为虚表指针放在最开头。

    (int *)(*(int *)&b)  //这就是b对象的虚表地址

    &b代表对象b的起始地址

     (int *)&b 强转成int *类型,为了后面取b对象的前四个字节,前四个字节是虚表指针，

    *(int *)&b 取前四个字节,即vptr虚表地址，
  
    (int *)转化为地址格式
    
    第一个虚函数地址*(int *)*(int *)&b
 

![](https://github.com/LLLibra/LLLibra.github.io/raw/master/_posts/imgs/20200411-101232.png)

![](https://github.com/LLLibra/LLLibra.github.io/raw/master/_posts/imgs/20200411-100418.png)

![](https://github.com/LLLibra/LLLibra.github.io/raw/master/_posts/imgs/20200411-101944.png)


我原本的问题是虚基类表到底是在怎样的情况下发送怎样的作用，虚基类表到底存的是什么，经过多天的资料查找和实践我终于弄清楚了一部分。首先要更正几个事，和上面有些重复。

1.虚基类表和虚表合而为一，也就是虚表中存的不仅仅是虚函数的地址了，就如上图所示。

2.vbase_offset是原本虚基表里的内容，相当于每个基类离虚基类的偏移。

3.top_offset 表示this指针对子类的偏移，用于子类和继承类之间dynamic_cast转换（还需要typeinfo数据），实现多态。（即你是如何找到你的基类成员，这个参数是即使没有虚继承也会有）

#### 虚基类表的使用场景
虚基类表用于多态式，比上面的C对象的指针指向的D对象，此时我们要访问虚基类A的成员，你是无法访问依靠C对象找到D对象中虚基类A的成员，因为偏移量不一样，而这个偏移量就存在虚基表也就是现在的虚表里。

依靠top_offset我们能迅速定位到任意一个基类，通过vbase_offset我们可以定位到虚基类。

* 如果不是通过指针访问，而是直接通过对象实例，则派生类的布局可以在编译期间静态获得，偏移量也可以在编译时计算，因此也就不必要根据虚基类表的表项来间接计算了。

* 大多数时候不需要用到虚表中的这些偏移量，具体可以看参考链接中的最后一个链接

参考链接：

https://www.cnblogs.com/alexcool/articles/9241548.html

https://www.cnblogs.com/Azhu/p/4443099.html

https://bbs.csdn.net/topics/320216733

https://blog.csdn.net/gudesheng/article/details/2169041?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522158657433919724845043886%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=158657433919724845043886&biz_id=0&utm_source=distribute.pc_search_result.none-task-blog-soetl_SOETLBAIDU-2

* 最后一篇比较重要 看的时候可以搜索关键字偏移量

## 虚表初始化顺序
1、分配内存

2、基类构造过程（按照无继承来）

3、初始化子类虚表指针

4、子类列表初始化

5、执行子类构造函数体

## 残留问题：
1.VTT表是什么

2.ptr to typrinfo D是什么


3.只有使用指针指向派生类对象时，通过指针访问虚基类成员需要用到那些虚表中的偏移量，我们现在知道如果这个指针的静态类型是派生类对象的话，访问非虚基类成员只需要layout的偏移量而不需要虚表中的偏移量，那问题就是如果这个指针是基类对象呢，那访问非虚基类成员事不是也需要用到虚表中的偏移量呢？(我猜测是的)
