---
layout: post
title:  "虚函数表"
data: 星期二, 25. 二月 2020 10:25上午 
categories: C++
tags: 专题
---
* 该模块会针对C++中的某一块知识做专题整理，也许会有些不足或者错误的地方，未来可能会作修改。

# C++专题7----虚函数表

* 探究虚函数更深层的原理

## 前言

1.虚函数（Virtual Function）是通过一张虚函数表（Virtual Table）来实现的，简称为V-Table。通过类中的虚表指针_vfptr来找到对应的虚函数。

2.表中主是要一个类的虚函数的地址表，这张表解决了继承、覆盖的问题，保证其容真实反应实际的函数。当我们用父类的指针来操作一个子类的时候，这张虚函数表就显得由为重要了，它就像一个地图一样，指明了实际所应该调用的函数。

3.同一个类的不同实例共用同一份虚函数表, 她们都通过一个所谓的虚函数表指针__vfptr(定义为void**类型)指向该虚函数表.在单继承中（非虚继承），派生类会产生一个新的虚表，新的虚表指针，虽然内容是继承基类，但是独立于基类，内容可能与基类不同。

4.不含虚函数的类A和含一个虚函数的类B相比（即有一个函数在A中实现是非虚，在B中却是虚函数），即使其他内容完全相同，但是后者会多4字节，因为多了一个指针_vfptr,指向一个函数地址数组（虚函数表），数组中保存所有虚函数的地址。派生类会继承基类函数指针数组里的元素，如果派生类有重写，那么重写后的函数地址会覆盖函数指针数组里的函数地址。调用函数时会去虚函数表中找函数。（注意这时我们为B类中再添加一个虚函数，B类的大小即sizeof(B)并不会发生变化，只是在虚函数表中添加一项。）


5.在C++的标准规格说明书中说到，编译器必需要保证虚函数表的指针存在于对象实例中最前面的位置，**这意味着我们通过对象实例的地址得到这张虚函数表，然后就可以遍历其中函数指针，并调用相应的函数。**

6.虚表指针是在调用构造函数初始化的，虚表存放于数据段（静态区或全局区），不能存放于栈和堆。

7.调用虚函数时，程序将查看存储在对象中的虚函数表地址，转向相应的虚函数表，使用类声明中定义的第几个虚函数，程序就使用数组的第几个函数地址，并执行该函数。

## 单继承中的虚函数表

#### 派生类不定义新的虚函数

![](https://github.com/LLLibra/LLLibra.github.io/raw/master/_posts/imgs/20200225-134217.png)

**内存偏移情况：**

基类：

![](https://github.com/LLLibra/LLLibra.github.io/raw/master/_posts/imgs/20200225-141833.png)

派生类：

![](https://github.com/LLLibra/LLLibra.github.io/raw/master/_posts/imgs/20200225-141804.png)

这是最简单的情况

![](https://github.com/LLLibra/LLLibra.github.io/raw/master/_posts/imgs/20200225-134247.png)

当然如果这里派生类对基类的虚函数进行了重写，那么派生类的虚表中的地址就会改变

![](https://github.com/LLLibra/LLLibra.github.io/raw/master/_posts/imgs/20200225-134551.png)

#### 派生类会定义新的虚函数
直接给结论，派生类的内存偏移不会发生变化，条目数和数字都不会变。原因在于派生类会直接把虚函数添加到继承而来的虚表中。就和我们在基类中添加虚函数但是基类的大小不会改变一样。

![](https://github.com/LLLibra/LLLibra.github.io/raw/master/_posts/imgs/20200225-142859.png)

我前面所说的正是这个图的左半部分，并不会变。

## 多继承中的虚函数表
按照基类的声明顺序，基类的成员依次分布在继承中。

![](https://github.com/LLLibra/LLLibra.github.io/raw/master/_posts/imgs/20200225-113847.png)

这里注意Derive类有两个基类Base1和Base2。d1是Derive的一个对象。
先讲讲几个原则：

1.如果Derive类有新的虚函数（基类中没有的虚函数），那么按照继承顺序找到第一个基类，插入到对应的虚表中（前提是有基类有虚表），如上例我们会将虚函数插入到Base1的虚表后面。(注意这个虚表是Derive类两个虚表中的一个,修改它并不会影响到原Base1中的虚表)

2.如果所有基类都没有虚函数，也就是没有虚表，那么派生类就自己创一个_vfptr指针放在所有基类后面。

3.在派生类中基类存储的优先顺序（继承顺序），首先看是否是虚继承（虚继承则排最后），再看有无虚函数(有虚函数优先)，再看声明顺序。如果再加一个基类为Base3,声明顺序为Base1,Base2,Base3,但是只有Base2没有基类，所以内存顺序是Base1,Base3,Base2，有虚函数就加入Base1部分中的虚表。

## 虚继承中的虚函数表

如果是虚继承，那么子类会有两份虚指针，一份指向自己的虚表，另一份指向虚基表，

虚基类派生出来的类中,虚基类的对象不在固定位置(应该是在尾部),需要一个中介才能访问虚基类的对象.所以子类需要有一个vbptr,对应的table中需要有一项指向虚基类.

虚基类表存储的是，虚基类相对直接继承类(派生类)的偏移。

指向虚基表的指针为vbptr（不占用类对象的存储空间） 

#### 单虚继承

1.如果派生类不添加虚函数，派生类会有两份虚指针，一份指向继承来的的虚表，另一份指向虚基表。

2.派生类如果添加新的虚函数，派生类会新增一个虚指针和虚表而不是添加到基类的虚表当中，所以类的大小会进一步增加。（不同于正常继承时添加新的虚函数并不增加类的大小）


#### 多重虚继承

**当基类全为虚继承：**

1.新添虚函数仍需要新开虚表和虚函数指针。

2.虚基表和虚基表指针只会有一个。

**当基类中有虚继承也有普通继承：**
待补充

#### 菱形继承
假设B和C虚继承A，D普通多重继承B和C。

那么D中会有B的两个指针，一个指向B的虚表一个指向B的虚基表

D中会有C的两个指针，一个指向C的虚表一个指向C的虚基表

D中会有A的指针，指向A的虚表

D中新添的虚函数会加到B的虚表中，并不会新增虚表

#### 虚继承的意义
如果B和C普通继承A   D能靠D.B:: 和D.C::访问B和C成员

而如果B和C虚继承A   D除了能靠D.B:: 和D.C::访问B和C成员 还能靠D.A::访问A的成员

**作用一：节约代码**
> 
这里面的区别就是D能否访问A的成员，如过BC是有一些东西都是一样的、基础的、不需要重写的，那么就可以用虚继承保证这些不需要被重写的东西可以通过D直接去A中访问到，不需要在B和C中都再保存一份，单单B保存就够了，而且即使A中的数据被B和C重写了也能访问了最原始的A的数据（虽然这条没什么用）。

**作用二：防止混淆**
>
对于继承体系中，如果B继承了A，C继承了B，即使C重写了B和A中的成员，C也可以通过C.A::和C.B::访问未重写的成员，所以大家对于如何访问祖父的数据有了认识，但是C++对于是谁的祖父是分不出的，假设C又继承了D，同时D继承了A，这时C.A::就会发生错误，因为系统发现C继承的B里有A的数据，D里也有A的数据，无法区分（就是这么笨），但是如果B和D对于A的继承是虚继承，那么C继承D的数据时就不会再有A的代码，和作用一呼应(具体的机制暂时未研究)，这时A就只有一个了，就可以使用C.A::。


## 残留问题：
1.多重继承中即有虚继承又有普通继承 那么新增虚函数是否会新增虚表（猜测应该不会）

2.看菱形继承有感 如果B虚单继承了A，C普通继承了B，那么C中会有A的虚表信息吗(应该会有)

3.虚基表的原理到底是什么，里面是什么东西

