---
layout: post
title:  "锁与死锁"
data: 星期日, 22. 三月 2020 04:24下午 
categories: 数据库
tags: 专题
---
* 该模块会针对数据库中的某一块知识做专题整理，也许会有些不足或者错误的地方，未来可能会作修改。

# 数据库专题3----锁与死锁

## 按功能分
#### 共享锁（读锁）
多个事务对同一数据进行共享一把锁，都能访问到数据，但是只能读不能修改。

#### 排它锁（写锁）
排他锁就是不能与其他锁并存，一个事务获取了一个数据行的排他锁，其他事务就不能再获取该行的其他锁，只有获取排他锁的事务可以对数据进行读取和修改。
>
可以直接通过select ...from...查询数据，因为普通查询没有任何锁机制。


#### 意向锁（只能是页级）
用来预定要对此页施加X锁（排它或共享），它允许其他事务读，但不允许再其他锁；当被读取的页将要被更新时，则升级为X锁；U锁一直到事务结束时才能被释放。

意向锁之间不互斥，即一个页表可以有多个意向锁

表示事务准备给数据行加入排他锁，说明事务在一个数据行加排他锁前必须先取得该页的X锁。

意向锁是InnoDB引擎（一种数据库引擎）自动加的，不需用户干预。意向锁不会与行级的共享 / 排他锁互斥！！！ 能提高效率。

![](https://github.com/LLLibra/LLLibra.github.io/raw/master/_posts/imgs/20200322-214720.png)

## 按范围分
#### 行级锁
行级锁是针对索引加的锁

**优点**
好处是锁定对象的颗粒度很小，发生锁冲突的概率低、并发度高；

**缺点**
缺点是开销大、加锁慢，行级锁容易发生死锁；

#### 页级锁
介于行级锁和表级锁之间

会产生死锁


#### 表级锁


## 乐观锁与悲观锁
#### 悲观锁
事务每次去操作数据的时候都假设有其他事务会修改需要访问的数据，所以在访问之前都要求上锁，行锁，表锁等，读锁，写锁等，都是在做操作之前先上锁，因此，在整个数据处理过程中，将数据处于锁定状态。悲观锁的实现，往往依靠数据库提供的锁机制（也只有数据库层提供的锁机制才能 真正保证数据访问的排他性，否则，即使在本系统中实现了加锁机制，也无法保证外部系 统不会修改数据）。


#### 乐观锁
事务每次去操作数据之前，都假设其他事务不会修改这些需要访问的数据 ，所以在访问之前不要求上锁，**只是在进行更新修改操作的时候判断一下在访问的期间有没有其他人修改数据 了,如果别人修改了数据则放弃操作，否则执行操作。**。它适用于多读的应用类型，冲突真的发生比较少的时候就比较好，这样省去了开销的开销，可以提高吞吐量;但如果是真的经常要发生冲突的，那每次还要去判断进行retry,反倒降低的性能，这个时候悲欢锁比较好。

> #### 乐观锁实现方式
>
**CAS**
>
如果内存位置V的值等于预期的A值，则将该位置更新为新值B，否则不进行任何操作。
>
这里引出一个新的问题，既然CAS包含了Compare和Swap两个操作，它又如何保证原子性呢？
答案是：CAS是由CPU支持的原子操作，其原子性是在硬件层面进行保证的。
>
许多CAS的操作是自旋的：如果操作不成功，会一直重试，直到操作成功为止。

>**版本号机制**
>
版本号机制的基本思路是在数据中增加一个字段version，表示该数据的版本号，每当数据被修改，版本号加1。
>
当某个线程查询数据时，将该数据的版本号一起查出来；
当该线程更新数据时，判断当前版本号与之前读取的版本号是否一致，如果一致才进行操作。
>
具体实现是，表中有一个版本字段，第一次读的时候，获取到这个字段。处理完业务逻辑开始更新的时候，需要再次查看该字段的值是否和第一次的一样。如果一样更新，反之拒绝。之所以叫乐观，因为这个模式没有从数据库加锁。


#### 两者对比
当竞争不激烈 (出现并发冲突的概率小)时，乐观锁更有优势，因为悲观锁会锁住代码块或数据，其他线程无法同时访问，影响并发，而且加锁和释放锁都需要消耗额外的资源。

当竞争激烈(出现并发冲突的概率大)时，悲观锁更有优势，因为乐观锁在执行更新时频繁失败，需要不断重试，浪费CPU资源。

## 死锁

#### 死锁预防
（1）按同一顺序访问对象。

（2）避免事务中的用户交互。

（3）保持事务简短并在一个批处理中。

（4）使用低隔离级别。

（5）使用绑定连接。


















