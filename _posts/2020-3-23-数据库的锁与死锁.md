---
layout: post
title:  "锁与死锁"
data: 星期日, 22. 三月 2020 04:24下午 
categories: 数据库
tags: 专题
---
* 该模块会针对数据库中的某一块知识做专题整理，也许会有些不足或者错误的地方，未来可能会作修改。

# 数据库专题3----锁与死锁

## 按功能分
#### 共享锁（读锁）
多个事务对同一数据进行共享一把锁，都能访问到数据，但是只能读不能修改。

#### 排它锁（写锁）
排他锁就是不能与其他锁并存，一个事务获取了一个数据行的排他锁，其他事务就不能再获取该行的其他锁，只有获取排他锁的事务可以对数据进行读取和修改。
>
可以直接通过select ...from...查询数据，因为普通查询没有任何锁机制。


#### 意向锁（只能是页级）
用来预定要对此页施加X锁（排它或共享），它允许其他事务读，但不允许再其他锁；当被读取的页将要被更新时，则升级为X锁；U锁一直到事务结束时才能被释放。

意向锁之间不互斥，即一个页表可以有多个意向锁

表示事务准备给数据行加入排他锁，说明事务在一个数据行加排他锁前必须先取得该页的X锁。

意向锁是InnoDB引擎（一种数据库引擎）自动加的，不需用户干预。意向锁不会与行级的共享 / 排他锁互斥！！！ 能提高效率。

![](https://github.com/LLLibra/LLLibra.github.io/raw/master/_posts/imgs/20200322-214720.png)

## 按范围分
#### 行级锁
行级锁是针对索引加的锁

**优点**
好处是锁定对象的颗粒度很小，发生锁冲突的概率低、并发度高；

**缺点**
缺点是开销大、加锁慢，行级锁容易发生死锁；

#### 页级锁
介于行级锁和表级锁之间

会产生死锁


#### 表级锁


## 乐观锁与悲观锁
#### 悲观锁
事务每次去操作数据的时候都假设有其他事务会修改需要访问的数据，所以在访问之前都要求上锁，行锁，表锁等，读锁，写锁等，都是在做操作之前先上锁，因此，在整个数据处理过程中，将数据处于锁定状态。悲观锁的实现，往往依靠数据库提供的锁机制（也只有数据库层提供的锁机制才能 真正保证数据访问的排他性，否则，即使在本系统中实现了加锁机制，也无法保证外部系 统不会修改数据）。


#### 乐观锁
事务每次去操作数据之前，都假设其他事务不会修改这些需要访问的数据 ，所以在访问之前不要求上锁，**只是在进行更新修改操作的时候判断一下在访问的期间有没有其他人修改数据 了**。它适用于多读的应用类型，冲突真的发生比较少的时候就比较好，这样省去了开销的开销，可以提高吞吐量;但如果是真的经常要发生冲突的，那每次还要去判断进行retry,反倒降低的性能，这个时候悲欢锁比较好。



#### 最迟提交事务或回滚事务就会释放锁。

## 死锁

#### 死锁预防
（1）按同一顺序访问对象。

（2）避免事务中的用户交互。

（3）保持事务简短并在一个批处理中。

（4）使用低隔离级别。

（5）使用绑定连接。


















