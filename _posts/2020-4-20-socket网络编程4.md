---
layout: post
title:  "socket网络编程4"
data: 星期二, 07. 四月 2020 11:33上午 
categories: linux
tags: 专题
---
* 该模块会针对linux中的某一块知识做专题整理，也许会有些不足或者错误的地方，未来可能会作修改。

# linux专题6----零碎知识


## 零拷贝
即所有的拷贝**完全在内核中完成**，避免了内核缓冲区和用户缓冲区之间的拷贝，效率很高。

常用的零拷贝有 

mmap（mmap+write方式）

 sendFile（用于两个文件描述符之间传数据）。

splice（用于两个文件描述符之间移动数据，但是发送方和接收方起码一个是管道）

tee（两个管道文件描述符赋值数据）



## 惊群效应
惊群现象就是多进程（多线程）在**同时阻塞等待同一个事件的时候（休眠状态）**，如果等待的这个事件发生，**那么他就会唤醒等待的所有进程（或者线程），但是最终却只可能有一个进程（线程）获得这个时间的“控制权”**，对该事件进行处理，而其他进程（线程）获取“控制权”失败，只能重新进入休眠状态，这种现象和性能浪费就叫做惊群。


#### accept()惊群
其实在linux2.6版本以后，linux内核已经解决了accept（）函数的“惊群”现象，通过引入一个标记位 WQ_FLAG_EXCLUSIVE，解决掉了 accept 惊群效应。大概的处理方式就是，当内核接收到一个客户连接后，只会唤醒等待队列上的第一个进程（线程）,所以如果服务器采用accept阻塞调用方式，在最新的linux系统中已经没有“惊群效应”了。

#### epoll惊群
如果多个进程/线程阻塞在监听同一个监听socket fd的epoll_wait上，当有一个新的连接到来时，所有的进程都会被唤醒。

**内核不会解决epoll惊群**

accept确实应该只能被一个进程调用成功，内核很清楚这一点。但epoll不一样，他监听的文件描述符，除了可能后续被accept调用外，还有可能是其他网络IO事件的，而其他IO事件是否只能由一个进程处理，是不一定的，内核不能保证这一点，这是一个由用户决定的事情，例如可能一个文件会由多个进程来读写。所以，对epoll的惊群，内核则不予处理。

**epoll_create 在 fork 之前创建**

与 accept 惊群的原因类似，当有事件发生时，等待同一个文件描述符的所有进程（线程）都将被唤醒，而且解决思路和 accept 一致。为什么需要全部唤醒？因为内核不知道，你是否在等待文件描述符来调用 accept() 函数，还是做其他事情（信号处理，定时事件）。此种情况惊群效应已经被解决。

**epoll_create 在 fork 之后创建**

我们知道 epoll 对惊群效应的修复，是建立在共享在同一个 epoll 结构上的。epoll_create 在 fork 之后执行，每个进程有单独的 epoll 红黑树，等待队列，ready 事件列表。因此，惊群效应再次出现了。有时候唤醒所有进程，有时候唤醒部分进程，可能是因为事件已经被某些进程处理掉了，因此不用在通知另外还未通知到的进程了。



#### 如何解决惊群
使用mutex锁住多个线程是不会惊群的，在某个线程解锁后，只会有一个线程会获得锁，其它的继续等待。




























