---
layout: post
title:  "文件编译过程"
data: 星期一, 16. 三月 2020 10:29下午  
categories: C++
tags: 专题
---
* 该模块会针对C++中的某一块知识做专题整理，也许会有些不足或者错误的地方，未来可能会作修改。

# C++专题13----文件编译过程


## 预编译阶段

* 只针对头文件

我们发现了头文件中有一些带#开头的关键字，如：#define,#ifndef,#endif,等等。预编译阶段就是处理这些伪指令的，


####  宏定义指令，如# define Name TokenString，# undef等。
对于前一个伪指令，预编译所要做的是将程序中的所有Name用TokenString替换，但作为字符串常量的 Name则不被替换。对于后者，则将取消对某个宏的定义，使以后该串的出现不再被替换。



#### 条件编译指令，如# ifdef，# ifndef，# else，# elif，# endif等。
这些伪指令的引入使得程序员可以通过定义不同的宏来决定编译程序对哪些代码进行处理。预编译程序将根据有关的文件，将那些不必要的代码过滤掉。


#### #include
1.在预编译过程中，#include将会被其文件内容替换，从而实现将函数声明放在main之前，为main函数中调用打下基础，这就是为什么#include为什么被放在cpp文件的开始部分。

![](https://github.com/LLLibra/LLLibra.github.io/raw/master/_posts/imgs/20200316-223623.png)


> #### 如何使得头文件和宏只被编译一次

>
方法1：#ifndef
 #ifndef，#define，#endif用来防止某个宏被多次定义。
>
方法2：#pragma once用来防止某个头文件被多次include

## 编译阶段（编译+汇编）
预编译在内存中输出翻译单元（就是将include等在源文件上替换了以后产生的临时文件）。

编译器接受临时文件，通过词法分析和语法分析，在确认所有的指令都符合语法规则之后，将其翻译成等价的中间代码表示或汇编代码。

汇编过程实际上指把汇编语言代码翻译包含机器语言指令的三个目标文件（main.obj、animal.obj、human.obj）。目标文件中所存放的也就是与源程序等效的目标的机器语言代码。

**c++编译的时候实际上只编译源文件，而不编译头文件**

**c++源文件中在包含头文件的地方，将被包含头文件中的代码全部拷贝进去进行编译**

## 链接阶段
由汇编程序生成的目标文件并不能立即就被执行，其中可能还有许多没有解决的问题。

例如，某个源文件中的函数可能引用了另一个源文件中定义的某个符号（如变量或者函数调用等）；在程序中可能调用了某个库文件中的函数，等等。所有的这些问题，都需要经链接程序的处理方能得以解决。

**链接程序的主要工作就是将有关的目标文件彼此相连接**，也即将在一个文件中引用的符号同该符号在另外一个文件中的定义连接起来，使得所有的这些目标文件成为一个能够被操作系统装入执行的统一整体。

**链接处理可分为两种：**

（1）静态链接**（静态库）**：（直接放入可执行文件）
* 只支持隐式加载（载入时加载）

在这种链接方式下，函数的代码将从其所在的静态链接库中被拷贝到最终的可执行程序中。这样该程序在被执行时这些代码将被装入到该进程的虚拟地址空间中。静态链接库实际上是一个目标文件的集合，其中的每个文件含有库中的一个或者一组相关函数的代码。

静态库的好处是编译完了就和它没关系了，但是一浪费空间（同一个模块被多个模块链接时，那么这个模块在磁盘和内存中都有多个副本），二是一旦代码发生变化就要所有使用这个库的文件都要重新编译

（2）动态链接（**动态库**）：（并不装入可执行文件）

* 既支持隐式加载（载入时加载），也支持显式加载（装入时加载）

在此种方式下，函数的代码被放到称作是动态链接库或共享对象的某个目标文件中。链接程序此时所作的只是在**最终的可执行程序**中记录下共享对象的名字以及其它少量的登记信息。在此可执行文件被执行时，动态链接库的全部内容将被映射到运行时相应进程的虚地址空间。**动态链接程序将根据可执行程序中记录的信息找到相应的函数代码。**

>
动态就是不对那些组成程序的目标文件进行链接，等到程序要运行时才进行链接。也就是说，把链接这个过程推迟到了运行时再进行，这就是动态链接（Dynamic Linking）的基本思想。
>
在动态链接程序运行时，除了可执行文件本身，将还有动态链接文件(**linux为.so,windows为.dll**)与动态链接器将被映射到进程的地址空间中，动态链接器被当做普通的共享对象来进行映射，在系统运行可执行文件之前，会将控制权交给动态链接器，由它完成所有的动态链接工作以后再把控制权交给可执行文件。

动态链接可以节约内存，但是在某些情况下动态链接可能带来一些性能上损害。

> #### 动态链接的隐式加载
>
用户源程序经编译后所得到的目标模块,是在装入内存时,边装入边链接的.即在装入一个目标模块时,若
>
发生一个外部模块调用,将引起装入程序去找出相应的外部目标模块,并将它装入内存,还要修改目标模块中的相对地址。
> #### 动态连接的显式加载
>
这种链接方式，可将某些目标模块的链接，推迟到执行时才进行。即在执行过程中，若发现一个被调用模块尚未装入内存时，由OS去找到该模块，将它装入内存，并把它连接到调用者模块上。
>
实际上，在许多情况下，每次要运行的模块可能是不相同的，但由于事先无法知道
本次要运行哪些模块，故只能是将所有可能要运行到的模块，在装入时全部链接在一起，是每次执行时的装入模块是相同的。显然这是低效的。因为这样，在装入模块的运行过程中，往往会有某些目标模块根本就不运行。比较典型的例子是错误处理模块.

## 番外------gcc和g++区别
习惯上，gcc编译c代码,g++编译c++代码，但不是绝对
>
编译阶段，g++会调用gcc，对于c++代码，两者是等价的，但是因为gcc命令不能自动和C＋＋程序使用的库联接，所以通常用g++来完成链接，为了统一起见，干脆编译/链接统统用g++了，这就给人一种错觉，好像cpp程序只能用g++似的。

![](https://github.com/LLLibra/LLLibra.github.io/raw/master/_posts/imgs/20200331-171109.png)






