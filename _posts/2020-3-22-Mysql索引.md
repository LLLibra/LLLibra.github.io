---
layout: post
title:  "mysql索引"
data: 星期日, 22. 三月 2020 04:24下午 
categories: 数据库
tags: 专题
---
* 该模块会针对数据库中的某一块知识做专题整理，也许会有些不足或者错误的地方，未来可能会作修改。

# 数据库专题1----mysql索引


## 什么是索引

索引也是一张表，该表中存储着索引的值和这个值的数据所在行的物理地址，使用索引后可以不用扫描全表来定位某行的数据，而是通过索引表来找到该行数据对应的物理地址。

DB在执行一条Sql语句的时候，默认的方式是根据搜索条件进行全表扫描，遇到匹配条件的就加入搜索结果集合。如果我们对某一字段增加索引，查询时就会先去索引列表中一次定位到特定值的行数，大大减少遍历匹配的行数，所以能明显增加查询的速度。

一般来说，索引本身也很大，不可能全部存储在内存中，因此索引往往以索引文件的形式存储的磁盘上。

* 索引建少了，用 WHERE 子句找数据效率低，不利于查找数据。索引建多了，不利于新增、修改和删除等操作，因为做这些操作时，SQL SERVER 除了要更新数据表本身，还要连带立即更新所有的相关索引，而且过多的索引也会浪费硬盘空间。

## 索引总类

#### 普通索引
普通索引是最基本的索引，它没有任何限制，允许在定义索引的列中插入重复值和空值
#### 唯一索引：
索引列的值必须唯一，允许有空值，如果是组合索引，列值的组合必须唯一
#### 主键索引
主键索引是一种特殊的唯一索引，一个表只能有一个主键，不允许有空值，一般是在创建表的时候指定主键，主键默认就是主键索引
>
![](https://github.com/LLLibra/LLLibra.github.io/raw/master/_posts/imgs/20200330-205955.png)

#### 组合索引
多个字段上创建的索引，只有在查询条件中使用了创建索引时的第一个字段，索引才会被使用

组合索引支持前缀索引

>
![](https://github.com/LLLibra/LLLibra.github.io/raw/master/_posts/imgs/20200325-145443.png)
>
![](https://github.com/LLLibra/LLLibra.github.io/raw/master/_posts/imgs/20200330-210020.png)

#### 全文索引
允许有重复值和空值，可以在char、varchar、text类型的列上创建。
主要用来查找文本中的关键字，而不是直接与索引中的值比较，它更像是一个搜索引擎

* 只能用于MyISAM类型的数据表

#### 空间索引
空间索引是对空间数据类型的字段建立的索引，Mysql中的空间索引类型有4种，GEOMETRY、POINT、LINESTRING、POLYGON，创建空间索引的列，必须将其声明为not null，Mysql中只有MyISAM存储引擎支持创建空间索引


## 实现方法

一般分为B+树索引和哈希索引。

#### B+树节点大小
这里我们就需要了解页(page)的概念，在计算机里，无论是内存还是磁盘，操作系统都是按页的大小进行读取的(页大小通常为 4 kb)，**磁盘每次读取都会预读，会提前将连续的数据读入内存中**，这样就避免了多次 IO，这就是计算机中有名的局部性原理，即我用到一块数据，很大可能这块数据附近的数据也会被用到，干脆一起加载，省得多次 IO 拖慢速度， 这个连续数据有多大呢，必须是操作系统页大小的整数倍，这个连续数据就是 MySQL 的页，默认值为**16 KB**，也就是说对于 B+ 树的节点，最好设置成页的大小(16 KB)，这样一个 B+ 树上的节点就只会有一次 IO 读。

通过以上分析，相信我们不难猜测出 N 叉树中的 N 该怎么设置了，只要选的时候尽量保证每个节点的大小等于一个页(16kb)的大小即可。

#### 为什么要用哈希索引

哈希索引O(1)在速度上毋庸置疑要快于B+树近似O(logn);

对于某些场景如热点页/活跃查询页，需要借助哈希索引来实现快速查询。

哈希索引只能进行等值查询（因为他要计算hash(key)再去匹配）而B+树索引可以进行等值、部分前缀、范围查询；

## 索引的优缺点

#### 优点
建立索引的列可以保证行的唯一性，生成唯一的row_Id

索引可以有效缩短数据的检索时间，减少I/O次数

索引可以加快表与表之间的连接

为用来排序和分组的字段建立索引可以加快分组和排序
#### 缺点
创建索引和维护索引需要时间成本，这个成本随着数据量的增大而加大

创建索引和维护索引需要空间成本，每一条索引都需要占据数据库的物理存储空间，数据量越大，占用空间也越大

会降低表的增删改的效率，因为每次增删改，索引需要进行动态维护

## 什么时候不该建立索引
1.在查询中很少使用或者参考的列不应该创建索引。

2.只有很少数据值的列也不应该增加索引。

3.定义为text、image和bit数据类型的列不应该增加索引。这是因为，这些列的数据量要么相当大，要么取值很少。

3.当修改性能远远大于检索性能时，不应该创建索引。这是因为，修改性能和检索性能是互相矛盾的。当增加索引时，会提高检索性能，但是会降低修改性能。当减少索引时，会提高修改性能，降低检索性能。因此，当修改性能远远大于检索性能时，不应该创建索引。



## 注意事项
1.不要在列上进行运算，这将导致索引失效而进行全表扫描
>
SELECT * FROM table_name WHERE YEAR(column_name)<2017;

2.不使用not in和<>操作

3.一般情况下不推荐使用like操作，如果非使用不可，如何使用也是一个问题。like “%aaa%” 不会使用索引而like “aaa%”可以使用索引。

4.查询只使用一个索引，因此如果where子句中已经使用了索引的话，那么order by中的列是不会使用索引的。因此数据库默认排序可以符合要求的情况下不要使用排序操作；尽量不要包含多个列的排序，如果需要最好给这些列创建复合索引。

5.对串列进行索引，如果可能应该指定一个前缀长度。例如，如果有一个char(255)的列，如果在前10个或20个字符内，多数值是惟一的，那么就不要对整个列进行索引。

6.只要列中包含有null值都将不会被包含在索引中，复合索引中只要有一列含有null值，那么这一列对于此复合索引就是无效的。所以我们在数据库设计时不要让字段的默认值为null。



## 聚类索引与非聚类索引
聚集索引的叶节点就是最终的数据节点，一般以主键作为索引。

非聚集索引的叶节仍然是索引节点，找到对应的主键

非聚集索引和聚集索引的区别在于， 通过聚集索引可以查到需要查找的数据， 而通过非聚集索引可以查到记录对应的主键值。通过聚集索引可以一次查到需要查找的数据， 而通过非聚集索引第一次只能查到记录对应的主键值 ， 再使用主键的值通过聚集索引查找到需要的数据。

不管以任何方式查询表， 最终都会利用主键通过聚集索引来定位到数据， 聚集索引（主键）是通往真实数据所在的唯一路径。

然而， 有一种例外可以不使用聚集索引就能查询出所需要的数据， 这种非主流的方法 称之为「覆盖索引」查询。这里就先不讲了。

![](https://github.com/LLLibra/LLLibra.github.io/raw/master/_posts/imgs/20200417-171009.png)

![](https://github.com/LLLibra/LLLibra.github.io/raw/master/_posts/imgs/20200417-171048.png)










