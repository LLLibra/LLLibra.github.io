---
layout: post
title:  "大数算法"
data: 星期三, 08. 四月 2020 04:21下午 
categories: 算法
tags: 专题
---
* 该模块会针对算法中的某一块知识做专题整理，也许会有些不足或者错误的地方，未来可能会作修改。

#  算法专题3----大数算法


## 10亿个数排序
快排 桶排 归并


## 10亿个数找中位数


#### 内存足够 用快排

• 随机选取一个数，将比它小的元素放在它左边，比它大的元素放在右边

• 如果它恰好在中位数的位置，那么它就是中位数，直接返回

• 如果小于它的数超过一半，那么中位数一定在左半边，递归到左边处理（还是第几大）

• 否则中位数一定在右半边，根据左半边的元素个数计算出中位数是右半边的第几大（重新算第几大），然后递归到右半边处理

#### 内存不够 用桶排

把所有数划分到各个小区间，把每个数映射到对应的区间里，对每个区间中数的个数进行计数，数一遍各个区间，看看中位数落在哪个区间，若够小，使用基于内存的算法，否则继续划分。


比如数是32位的，根据每个整数的二进制前5位，划分为32个桶，把数放进对应桶中。如果该桶放不下，继续划分，直至内存可以放心为止。统计每个桶中元素个数，算出中位数一定出现在哪个桶中，而且计算出是该桶中的第几大。

#### 内存不够 二分（类似桶排也有点像快排）
假设10亿个数字保存在一个大文件中，依次读一部分文件到内存(不超过内存的限制)，将每个数字用二进制表示，比较二进制的最高位(第32位，符号位，0是正，1是负)，如果数字的最高位为0，则将这个数字写入 file_0文件中；如果最高位为 1，则将该数字写入file_1文件中。

从而将10亿个数字分成了两个文件，假设 file_0文件中有 6亿 个数字，file_1文件中有 4亿 个数字。那么中位数就在 file_0 文件中，并且是 file_0 文件中所有数字排序之后的第 1亿大的数字。（file_1中的数都是负数，file_0中的数都是正数，也即这里一共只有4亿个负数，那么排序之后的第5亿个数一定位于file_0中）

现在，我们只需要处理 file_0 文件了（不需要再考虑file_1文件）。对于 file_0 文件，同样采取上面的措施处理：将file_0文件依次读一部分到内存(不超内存限制)，将每个数字用二进制表示，比较二进制的 次高位（第31位），如果数字的次高位为0，写入file_0_0文件中；如果次高位为1，写入file_0_1文件中。

现假设 file_0_0文件中有3亿个数字，file_0_1中也有3亿个数字，则中位数就是：file_0_0文件中的数字从小到大排序之后的第1亿个数字。

抛弃file_0_1文件，继续对 file_0_0文件 根据 次次高位(第30位) 划分，假设此次划分的两个文件为：file_0_0_0中有0.5亿个数字，file_0_0_1中有2.5亿个数字，那么中位数就是 file_0_0_1文件中的所有数字排序之后的 第0.5亿 个数。




## 10亿个数找前10000大的数

#### 建堆

先拿出10000个建立小根堆，对于剩下的元素，如果大于堆顶元素的值，删除堆顶元素，再进行插入操作，否则直接跳过，这样知道所有元素遍历完，堆中的10000个就是最大的10000个。时间复杂度: m + (n-1)logm = O(nlogm)

#### 优化的方法

可以把所有10亿个数据分组存放，比如分别放在1000个文件中（如果是字符串hash(x)%M）。对每个文件，建立大小为10000的小根堆，然后按有序数组的合并合并起来，取出最大的10000个即是答案。


## 10亿个数只有一个数重复出现 如何找出
使用同在2.5亿个整数中找出不重复的整数的bitmap


## 10亿个数找出重复次数最多的数

分桶，找出每个桶中出现最多的数


## 两堆10亿个数，如何找出其中在两个堆都有的数

将两堆数都分桶，然后一次处理两个通

## 2.5亿个整数中找出不重复的整数，注，内存不足以容纳这2.5亿个整数。

#### 使用bitmap
采用2-Bitmap（每个数分配2bit，00表示不存在，01表示出现一次，10表示多次，11无意义）进行，共需内存2^32 * 2 bit=1 GB内存，还可以接受。然后扫描这2.5亿个整数，查看Bitmap中相对应位，如果是00变01，01变10，10保持不变。所描完事后，查看bitmap，把对应位是01的整数输出即可。

#### 分桶
也可采用与第1题类似的方法，进行划分小文件的方法。然后在小文件中找出不重复的整数，并排序。然后再进行归并，注意去除重复的元素。


## 10亿个数找出重复次数前100的数
哈希 分桶 统计 归并


## 10亿个unsigned int的整数快速判断某一个在不在

#### 方法一
申请512M的内存，一个bit位代表一个unsigned int值。读入40亿个数，设置相应的bit位，读入要查询的数，查看相应bit位是否为1，为1表示存在，为0表示不存在。

#### 方法二：
类似10亿个数找中位数里的二分法









