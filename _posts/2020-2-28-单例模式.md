---
layout: post
title:  "单例模式"
data: 星期五, 28. 二月 2020 04:12下午 
categories: C++
tags: 专题
---
* 该模块会针对C++中的某一块知识做专题整理，也许会有些不足或者错误的地方，未来可能会作修改。

# C++专题9----单例模式

## 什么是单例
单例模式是设计模式的一种，只提供唯一一个类的实例，如果有多个对象的话，可能会导致状态的混乱和不一致，这个类具有全局变量的特点，在任何位置都可以通过接口获取到那个唯一实例。因为只能有一个实例，所以构造函数应该是私有的。

单例模式常用的有三种，分别是饿汉式、懒汉式和多线程式。

## 单例的特点
1.全局只有一个实例：static 特性，同时禁止用户自己声明并定义实例（把构造函数设为 private）

2.线程安全

3.禁止赋值和拷贝

4.用户通过接口获取实例：使用 static 类成员函数

## 懒汉式
 懒汉式的特点是延迟加载，比如配置文件，实例直到用到的时候才会加载
 
![](https://github.com/LLLibra/LLLibra.github.io/raw/master/_posts/imgs/20200228-165908.png)

并不采用构造函数而是调用GetInstance方法获取实例，即使多次调用该方法也只有一个实例，都是同一个指针。

** 缺点：**

** 问题一：线程安全 **

如果有两个线程同时获取单例类的实例，都发现实例不存在，因此都会进行实例化，就会产生两个实例都要赋值给instance_，这是严重的错误。为了解决这个问题，就要考虑加锁。如下所示。

![](https://github.com/LLLibra/LLLibra.github.io/raw/master/_posts/imgs/20200228-171129.png)

** 问题二：内存泄漏 **

只分配了动态内存却没有在析构函数中释放内存，解决方法：(1)智能指针(2)静态的嵌套类对象（在嵌套类内写一个析构函数，在程序运行结束时，系统会调用静态成员析构函数，该析构函数会删除单例的唯一实例。）

** 注意：**不能直接用单例类中的析构函数释放资源，会造成无限递归。


#### 更好的解决方案
遵照Effective C++ 条款4，可以看我的Effective C++1读书笔记。

![](https://github.com/LLLibra/LLLibra.github.io/raw/master/_posts/imgs/20200228-174613.png)

静态局部变量只会定义一次

** 保留问题：** 这种情况如何解决内存泄漏

#### 优点
避免了饿汉式的那种在没有用到的情况下创建事例，资源利用率高，不执行getInstance()就不会被实例。

#### 缺点
 1.第一次加载时反应不快

2.原始版本有线程安全和内存泄漏的问题
#### 适用场景
在访问量较小时，采用懒汉实现。这是以时间换空间。

## 饿汉式
饿汉式的特点是一开始就加载了，一开始就创建了实例，所以每次用到的之后直接返回就好了。

![](https://github.com/LLLibra/LLLibra.github.io/raw/master/_posts/imgs/20200229-180740.png)

由于在main函数之前初始化，所以没有线程安全的问题。但是潜在问题在于no-local static对象（函数外的static对象）在不同编译单元中的初始化顺序是未定义的，也即，static Singleton instance;和static Singleton& getInstance()二者的初始化顺序不确定，如果在初始化完成之前调用 getInstance() 方法会返回一个未定义的实例。

#### 优点
 1.线程安全 
 
 2.在类加载的同时已经创建好一个静态对象，调用时反应速度快 
#### 缺点
资源效率不高，可能getInstance()永远不会执行到，但执行该类的其他静态方法或者加载了该类（class.forName)，那么这个实例仍然初始化 


#### 适用场景
所以在访问量比较大，或者可能访问的线程比较多时，采用饿汉实现，可以实现更好的性能。这是以空间换时间。



