---
layout: post
title:  "static和const"
data: 星期六, 22. 二月 2020 04:30下午 
categories: C++
tags: 专题
---
* 该模块会针对C++中的某一块知识做专题整理，也许会有些不足或者错误的地方，未来可能会作修改。

# C++专题6----static和const

* static和const可以和C++中的很多部分地方使用，我只能尽量整理，若有不足或者错误，将会在未来补充和修改
## Static

#### static与变量
> 我的C++专题5内存分布的博文中有讲静态全局变量和静态局部变量

#### static与函数
>
普通函数可以在其他文件中被调用，但是静态函数只能在本文件中被调用。

#### static与类
> 1.静态成员先于类的声明而存在于内存，静态成员不存在生产期的问题，因为它始终驻留在内存,也分配在全局区。析构函数无法是否敬爱成员。

>
2.类的外部可以定义静态成员函数，在类的外部定义静态成员不需要重复定义static，只需要在类内部声明的时候加入static。

>
3.如果基类定义了一个静态成员，则在整个继承体系中只存在该成员的唯一定义

>
4.类中的静态成员变量的初始化必须在类外实现！！
因为静态成员属于整个类，而不属于某个对象，如果在类内初始化，会导致每个对象都包含该静态成员，这是矛盾的。

** 类的静态变量**：

![](https://github.com/LLLibra/LLLibra.github.io/raw/master/_posts/imgs/20200222-183153.png)

初始化时使用作用域运算符来标明它所属类，因此，静态数据成员是类的成员，而不是对象的成员。

** 类的静态函数**：

![](https://github.com/LLLibra/LLLibra.github.io/raw/master/_posts/imgs/20200222-174118.png)

![](https://github.com/LLLibra/LLLibra.github.io/raw/master/_posts/imgs/20200222-174133.png)


静态成员函数由于不是与任何的对象相联系,因此它不具有this指针.从这个意义上来说,它无法访问属于类对象的非静态数据成员，也无法访问非静态成员函数，只能调用其他的静态成员函数.

** 注意:**

1.静态成员函数可以继承和覆盖，但无法是虚函数；(如果定义为虚函数，那么它就是动态绑定的，也就是在派生类中可以被覆盖的，这与静态成员函数的定义（在内存中只有一份拷贝；通过类名或对象引用访问静态成员）本身就是相矛盾的。
)
2.虽然静态成员无法在类内初始化，但是静态常量成员行。
## Const

>
当多个文件里出现了同名的const对象时,等同于在不同的文件中定义了独立的变量。也可以通过extern来获得其他文件的const变量。？？？

#### const与变量
![](https://github.com/LLLibra/LLLibra.github.io/raw/master/_posts/imgs/20200223-135430.png)

两种定义方式都可以，const修饰的变量无法修改。

#### const与指针
** 举三个例子**

const int * pOne;    //指向整形常量 的指针，它指向的值不能修改（底层const，指向的对象是个常量）

int * const pTwo;    //指向整形的常量指针 ，它不能在指向别的变量，但指向（变量）的值可以修改。 （顶层const，指针本身是常量）

const int *const pThree;  //指向整形常量 的常量指针 。它既不能再指向别的常量，指向的值也不能修改。


#### const与函数
** const修饰形参**
>
我们这里分几种情况讨论
>
1.如果形参是自定义类型，常见用法是引用加const来修饰形参，能起到加速的作用，具体分析可以看我的Effective C++读书笔记第二部分，条款20来了解这一部分。
>
2.如果形参是内置类型，则传入的为副本，最好不要加const，也不要尝试const加引用的方式，反而降低效率。所以不要尝试将函数void Func1(int x) 写成void Func1(const int x)之类的行为，因为这个值传递，x是副本，没有保护的意义。
>
3.如果形参是指针,const修饰的函数参数是指针时,代表在函数体内不能修改该指针所指的内容，起到保护作用,const指针可以接收非const和const指针，而非const指针只能接收非const指针。

** const修饰返回值**
>
这个和形参的道理类似，我们分类讨论。
>
1.返回的是普通的内置类型，那样则会返回一个副本，const并没有用。所以不要尝试诸如把函数int GetInt(void) 写成const int GetInt(void)的行为。
>
2.返回自定义类型，比如A，
>>
将函数A GetA(void) 改写为const A &GetA(void)的确能提高效率。但此时千万千万要小心，一定要搞清楚函数究竟是想返回一个对象的“拷贝”还是仅返回“别名”就可以了，否则程序会出错。
>>>
![](https://github.com/LLLibra/LLLibra.github.io/raw/master/_posts/imgs/20200223-161144.png)
>>>
如果将赋值函数的返回值加const修饰，那么该返回值的内容不允许被改动。上例中，语句a= b = c 仍然正确，但是语句(a= b) = c 则是非法的。
>>
const 修饰自定义类型的作为返回值，此时返回的值不能作为左值使用，既不能被赋值，也不能被修改。
>
3.返回指针类型类型。那么函数返回值（即指针）的内容不能被修改，该返回值只能被赋给加const修饰的同类型指针。
>>
![](https://github.com/LLLibra/LLLibra.github.io/raw/master/_posts/imgs/20200223-154145.png)



#### const与类
** const成员变量**
>
const 修饰数据成员：初始化位置可以在参数列表中，可以在声明位置直接初始化（C++11修改，原本只能在参数列表中初始化）

** const成员函数**
>>
定义：
>>
void some_member() const;
>>
void Screen::some_member() const{}
>>
const在最后因为修饰的是this指针
>
因为非const函数可能修改数据成员，const成员函数是不能修改数据成员的,不论对方是否是const，所以当non-const和const实现相同功能时，non-const对象可以调用const成员函数(优先调用重载的non-const成员函数),  const对象（const对象指针）不能调用non-const成员函数, 所以用const写函数可以缩减代码量。(注意类中存在指针类型的数据成员即便是const函数只能保证不修改该指针的值，并不能保证不修改指针指向的对象。)

>
如果 const 构成函数重载，const 对象只能调用 const 函数，非 const 对象优先调用非 const 函数。

>
** 注意：**
>
1.看博客的时候看到一种说法，非const成员函数不能访问const成员变量，后发现只要不修改还是可以访问的。
>
2.static不能和const同时修饰一个成员函数，因为static成员函数并没有this指针

#### const成员函数的重载
当形参中有引用或者指针的时候，即使参数列表完全相同，non-const成员函数和const成员函数属于重载，但是没有引用和指针的时候，参数列表相同就不能算重载。


#### const与#define
可以看看我的Effective C++读书笔记第一部分，条款2就是讲要用const代替#define

宏定义: 由预处理处理,单纯的是纯文本替换。

const常量: 由C++编译器处理,提供类型检查和作用域检查。

