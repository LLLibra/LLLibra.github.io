---
layout: post
title:  "内存泄漏"
data: 星期三, 19. 二月 2020 03:23下午 
categories: C++
tags: 专题
---
* 该模块会针对C++中的某一块知识做专题整理，也许会有些不足或者错误的地方，未来可能会作修改。

# C++专题5----内存泄漏

本篇博文主要是总结一下C++中可能出现内存泄漏的情况，以及如何应对。

##什么是内存泄漏
内存泄漏（Memory Leak）是指程序中己动态分配的堆内存由于某种原因程序未释放或无法释放，造成系统内存的浪费，导致程序运行速度减慢甚至系统崩溃等严重后果。

## 可能会发生内存泄漏的情况

#### new出来的内存没有通过delete合理的释放掉
** 数组问题 **
1.new创建了一组对象数组，内存回收的时候却只调用了delete而非delete []来处理，导致只有对象数组的第一个对象的析构函数得到执行并回收了内存占用，数组的其他对象所占内存得不到回收，导致内存泄露；

** 空指针**
2.delete掉一个void*类型的指针，导致没有调用到对象的析构函数，析构的所有清理工作都没有去执行从而导致内存的泄露。（若一个void类型指针指向了一个类，那么系统在释放这个指针时并不会调用该类中的析构函数去释放内存）

** 异常退出**
3.关于全局变量的指针类型，程序在退出时(非正常)，动态创建的对象还存在于内存中，导致内存泄漏

** 类中成员**
4.类所有动态分配的成员变量，一定记得在析构函数中全部进行判断释放内存。当类中有指针成员变量，很多人喜欢在构造函数中来动态分配初始化指针变量但常常忘了在析构函数中来释放内存。

** vector（貌似List也会，之后再更新）**
5.使用std::vector< CType* >时，记得在clear或是删除一个元素之前，应该释放指针指向的内容。若是简单结构、简单类，你直接用std::vector< CType >可以避免内存泄漏错误。 vector.clear, vector.earse不会释放程序员自己动态分配的内存

** 指针赋值 **
6.如果不是定义指针作用范围内，使用其他地方的指针（如全局指针，类成员指针变量）赋值时，首先判断该指针是否为NULL,为NULL时new一块内存，否则，考虑重用原来的内存或先删除后new内存。因为若指针原来有值的话，你一覆盖原来分配的内存就再也找不到了，也就产生了泄漏。

** 异常分支 **
7.若正常分支有内存需要释放，则不要忘了异常分支的内存释放如try语句的catch分支，函数中的多个return分支都要考虑到相应内存的释放。 

** 非常规动态内存分配 **
8.不是采用常规内存分配(new、malloc、calloc、realloc)的内存也要记得释放，如strdup等。 有一些C/C++ Api返回的指针是动态分配的需要使用者来负责释放，这个只要使用时看清楚Api的说明就不会有什么问题了。 

** 虚析构函数**
9.当针对接口进行编程时，涉及到动态分配的对象指针在各函数间传递时特别要注意将基类的析构函数定义成虚函数，因为非虚函数是静态绑定的。
>
**将可能会被继承的父类的析构函数设置为虚函数，可以保证当我们new一个子类，然后使用基类指针指向该子类对象，释放基类指针时可以释放掉子类的空间，防止内存泄漏。**
>
虽然我们大部分时候要将析构函数设为虚函数  但这不是必须的

** 指针形参：**
10.如果你尝试将一个指针传入函数并申请空间，因为这个指针是一个拷贝，虽然里面存的地址是在堆中，出了这个函数这个指针申请的空间并不会带出去。
>
如果非得要去函数里，用指针形参参数去申请内存
>
选择一：那么应该改用“指向指针的指针”
>
选择二：函数返回这个指针


** 扫尾函数（并不了解）**
有些类型对象如CDialog，CWindow，CFile，CImage等需要在Delete前做Close、Release、Destroy等操作的，Delete时检查是否已经调用了相应的扫尾函数。

这个要具体情况具体分析了，比如CDialog的子类销毁时往往需要先调用OnDestroy或是DestroyWindow，不然就可能会存在资源泄漏的问题。


## 应对方法
1.智能指针

2.借助一些工具

## 残留问题
如何定位




