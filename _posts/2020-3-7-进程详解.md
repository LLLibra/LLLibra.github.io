---
layout: post
title:  "进程详解"
data: 星期五, 06. 三月 2020 01:29下午 
categories: 操作系统
tags: 专题
---
* 该模块会针对操作系统中的某一块知识做专题整理，也许会有些不足或者错误的地方，未来可能会作修改。

#  操作系统专题2----进程详解

* 本文会接着上一个专题 再讲一下进程的一些东西

## 进程控制块（PCB）
#### 什么是进程控制块
进程控制块是操作系统管理控制进程运行所用的信息集合。

操作系统用PCB来描述进程的基本情况以及运行变化的进程，PCB是进程存在的唯一标志。

![](https://github.com/LLLibra/LLLibra.github.io/raw/master/_posts/imgs/20200307-190513.png)

#### 进程控制块的组织方式

![](https://github.com/LLLibra/LLLibra.github.io/raw/master/_posts/imgs/20200307-190628.png)

一般用链表，因为可以动态插入和删除，但是如果从开始到结尾进程的数目就固定可以采用索引的方式。（下面的消息队列是用链表实现的队列，实际还是链表）

#### 进程控制块包含的三大类消息
![](https://github.com/LLLibra/LLLibra.github.io/raw/master/_posts/imgs/20200307-191304.png)

![](https://github.com/LLLibra/LLLibra.github.io/raw/master/_posts/imgs/20200307-191309.png)

![](https://github.com/LLLibra/LLLibra.github.io/raw/master/_posts/imgs/20200307-191313.png)


## 进程状态

>
这里先不讲死锁，死锁会另开一章

**进程有三个状态：运行态、就绪态和等待（阻塞）态**

![](https://github.com/LLLibra/LLLibra.github.io/raw/master/_posts/imgs/20200307-162600.png)

#### 进程阻塞
进程只能自己阻塞自己，因为只有进程自身才知道何时需要等待某种事情的发送。

**进程阻塞的可能原因：**

1.请求并等待系统服务，无法马上完成

2.启动某种操作，无法马上完成

3.需要的数据没有到达

#### 进程就绪

**进程唤醒（阻塞->就绪）的可能原因：**

1.被阻塞的进程需要的资源可被满足

2.被阻塞进程等待的时间到达

3.将该进程的PCB插入到就绪队列

**运行->就绪的可能原因**

时间片用完

#### 进程挂起
进程在挂起状态，意味着进程没有占用内存空间，处于挂起状态的进程映像在磁盘上。（内存页被换出）

**进程阻塞挂起：**进程在外存并等待某事件出现

**就绪挂起状态：**进程在外存，但只要进入内存，即可运行。

![](https://github.com/LLLibra/LLLibra.github.io/raw/master/_posts/imgs/20200307-171331.png)


## 状态队列

#### 状态队列

由操作系统维护的一组队列，用来表示系统中所有进程的当前状态，不同的状态分别用不同的队列来表示（就绪队列和各种阻塞队列）。每个进程 PCB都根据它的状态加入到相应的队列中，当一个进程 状态发送变化时，它的PCB从一个状态队列脱离出来，加入到另外一个队列。

因为优先级不同或者阻塞原因不同会有许多个队列。

* 这里起始还有一个僵尸队列  放置僵尸进程 僵尸进程的概念后面会讲

##上下文切换
上下文切换只能发生在内核态中

上下文切换（有时也称做进程切换或任务切换）是指 CPU 从一个进程或线程切换到另一个进程或线程。

**程序计数器**是一块较小的内存空间，它可以看作是当前线程所执行字节码的行号指示器。

内核的这种切换过程伴随的最显著的性能损耗是将寄存器中的内容切换出。

#### 进程上下文切换

（1）停止当前运行程序（从运行状态改为其他状态）并且调度其他进程（转变称运行状态）

**需要存储的上下文：**CPU 寄存器、虚拟内存、栈等资源和CPU、程序计数器状态等，这些上下文会储存到PCB的一个位置，恢复的时候拿出来。


（2）在内存中检索下一个进程的上下文并将其在 CPU 的寄存器中恢复，

（3）跳转到程序计数器所指向的位置（即跳转到进程被中断时的代码行），以恢复该进程。

#### 线程上下文切换
线程切换时需要知道在这之前当前线程已经执行到哪条指令了，所以需要记录程序计数器的值，另外比如说线程正在进行某个计算的时候被挂起了，那么下次继续执行的时候需要知道之前挂起时变量的值时多少，因此需要记录CPU寄存器的状态。所以一般来说，线程上下文切换过程中会记录程序计数器、CPU寄存器状态等数据。

这些信息可能会存储在TCB中

#### 两者区别
线程上下文切换和进程上下问切换一个最主要的区别是线程的切换虚拟内存空间依然是相同的，但是进程切换是不同的。即进程切换需要切换页目录以使用新的地址空间。

## 进程控制
#### 进程创建（fork函数）
  fork函数，它从已存在进程中创建一个新进程。新进程为子进程，而原进程为父进程。
  
**创建进程的一般工作：**

1.分配一个PCB，拷贝父进程的PCB的绝大部分数据

2.给子进程分配资源

3.复制父进程地址空间的数据

4.将进程状态置为就绪态，插入就绪队列

**fork函数的返回值：**子进程返回0，父进程返回的是子进程的pid。

调用这个函数 会发现多出一个进程 那个就是子进程

#### Exec(大部分情况下我们调用完fork之后会调用exec)
Exec()加载程序取代当前运行的进程
一个进程一旦调用exec类函数，它本身就"死亡"了，系统把代码段替换成新的程序的代码，废弃原有的数据段和堆栈段，并为新程序分配新的数据段与堆栈段，唯一留下的，就是进程号，也就是说，对系统而言，还是同一个进程，不过已经是另一个程序了。

#### vfork
由于fork后执行exec会丢弃大部分内容，所以这里就有很大的优化空间，vfork相当于fork的时候只复制一部分。

>
出于效率考虑，linux中引入了“写时复制“技术，也就是只有进程空间的各段的内容要发生变化时，才会将父进程的内容复制一份给子进程。于是起初我就感到奇怪，子进程的物理空间没有代码，怎么去取指令执行exec系统调用呢？！原来在fork之后exec之前两个进程用的是相同的物理空间（内存区），子进程的代码段、数据段、堆栈都是指向父进程的物理空间，也就是说，两者的虚拟空间不同，但其对应的物理空间是同一个。当父子进程中有更改相应段的行为发生时，再为子进程相应的段分配物理空间，如果不是因为exec，内核会给子进程的数据段、堆栈段分配相应的物理空间（至此两者有各自的进程空间，互不影响），而代码段继续共享父进程的物理空间（两者的代码完全相同）。而如果是因为exec，由于两者执行的代码不同，子进程的代码段也会分配单独的物理空间。

#### 进程等待
![](https://github.com/LLLibra/LLLibra.github.io/raw/master/_posts/imgs/20200308-203600.png)

Wait的作用：比如父进程可以帮助子进程内存（PCB）回收。


#### 进程终止

在子进程调用了exit但是资源没有被父进程回收，就是一个僵尸进程，如果父进程先于子进程没了，那么就要靠根进程（最早的进程 ）定期扫描来回收僵尸进程


## 进程调度算法

#### 先来先服务调度算法

#### 时间片轮转调度法
紧迫任务响应慢。 
#### 短作业(SJF)优先调度算法
**对长作业不利。会导致饥饿** 

**完全未考虑作业(进程)的紧迫程度**

**由于作业(进程)的长短只是根据用户所提供的估计执行时间而定的，而用户又可能会有意或无意地缩短其作业的估计运行时间，致使该算法不一定能真正做到短作业优先调度。 **


#### 最短剩余时间优先
​ 最短剩余时间是针对最短进程优先增加了抢占机制的版本。

#### 高响应比优先调度算法
​ 根据比率：R=(w+s)/s （R为响应比，w为等待处理的时间，s为预计的服务时间）

**优点：**

等待时间相同的作业，则要求服务的时间愈短，其优先权愈高，——对短作业有利 

要求服务的时间相同的作业，则等待时间愈长，其优先权愈高，——是先来先服务 

长作业，优先权随等待时间的增加而提高，其等待时间足够长时，其优先权便可升到很高， 从而也可获得处理机——对长作业有利 

**缺点：**要进行响应比计算，增加了系统开销
#### 优先级调度算法
赋予各个队列中进程执行时间片的大小也各不相同，在优先级越高的队列中，每个进程的运行时间片就越小。

当一个新进程进入内存后，首先将它放入第1级队列的末尾，按FCFS原则排队等待调度。当轮到该进程执行时，如它能在该时间片内完成，便可准备撤离系统；如果它在一个时间片结束时尚未完成，调度程序便将该进程转入第2级队列的末尾，再同样地按FCFS 原则等待调度执行；如果它在第2级队列中运行一个时间片后仍未完成，再以同样的方法放入第3级队列……如此下去，当一个长进程从第1级队列依次降到第 n 级队列后，在第 n 级队列中便釆用时间片轮转的方式运行。






