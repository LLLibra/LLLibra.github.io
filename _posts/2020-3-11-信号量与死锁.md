---
layout: post
title:  "死锁、信号量与管程"
data: 星期三, 11. 三月 2020 07:05下午 
categories: 操作系统
tags: 专题
---
* 该模块会针对操作系统中的某一块知识做专题整理，也许会有些不足或者错误的地方，未来可能会作修改。

#  操作系统专题6----死锁、信号量与管程

## 死锁


#### 死锁出现的必要条件
![](https://github.com/LLLibra/LLLibra.github.io/raw/master/_posts/imgs/20200311-191412.png)


### 死锁预防
只要让死锁出现的必要条件不要满足就行。

1.互斥：很难处理，你很难让所有资源都是共享的，总有互斥的

2.占有并等待：可以一次性拿到所有需要的资源，但是这种做法会大大降低系统的运行效率

3.无抢占：杀死一些占有独享资源的进程

4.循环等待：给资源编号，让每个进程按照资源的顺序申请。把资源按顺序排好，只能按递增的顺序申请资源。（嵌入式系统用的多）



### 死锁避免
需要系统具有一些额外的先验信息，即每个进程声明它可能需要的每个类型资源的最大数目。

![](https://github.com/LLLibra/LLLibra.github.io/raw/master/_posts/imgs/20200311-191952.png)


* **注意系统处于不安全状态并不是一定会死锁，只是可能会死锁。**

> #### 死锁避免-银行家算法（贪心算法）
>
![](https://github.com/LLLibra/LLLibra.github.io/raw/master/_posts/imgs/20200311-192228.png)
>
![](https://github.com/LLLibra/LLLibra.github.io/raw/master/_posts/imgs/20200311-192213.png)
>
**流程很简单。就是看有没有进程按照现在有的资源可以完成任务的，可以就把资源给它，完成了就把所有资源放出来。**
>
**缺点：**银行家算法需要提前知道每个进程所需要的最大资源的个数，这个正常情况是很难知道的，这也是这个算法不常用的原因之一。
### 死锁检测

![](https://github.com/LLLibra/LLLibra.github.io/raw/master/_posts/imgs/20200311-192447.png)

即找出所有占了资源的进程，然后看有没有能使用目前空闲的资源完成进程的，有就完成进程并释放资源，如果最终仍有占了资源的进程，那就是有死锁。

检测算法和银行家算法的区别是，检测算法只管你有没有占资源，如果你在运行但是你没占资源，那么你和没没运行的进程是一样的。

复杂度大 一般调试的时候才会用

### 死锁恢复
![](https://github.com/LLLibra/LLLibra.github.io/raw/master/_posts/imgs/20200311-191620.png)

![](https://github.com/LLLibra/LLLibra.github.io/raw/master/_posts/imgs/20200311-191625.png)


## 信号量
#### 信号量的使用场景
1.互斥

2.条件同步（调度约束，即一个线程等待另一个线程的事情发生）

#### 信号量的特点
1.PV操作是原子操作

2.初始化完成后，唯一一个改变信号量的办法是通过P()和V()

#### 整型信号量
只要信号量s≤0就不断测试，不满足让权等待。CPU会忙等。

#### 记录型信号量
如果剩余资源数不够，则会使进程从运行态进入阻塞态，并将其挂入对应信号量的等待队列，每次释放资源的时候都会看看对应等待队列中有没有进程。CPU不会忙等。

#### AND型信号量
基本思想：将进程在整个运行中需要的所有资源，一次性全部分配给进程，待进程使用完后一起释放。（避免死锁状态）在Wait中加入AND条件，又称AND同步或同时wait操作：Swait。

#### 信号量集

信号量集是指同时需要多个资源时的信号量操作。

一般也使用AND型信号量

## 管程

#### 什么是管程
![](https://github.com/LLLibra/LLLibra.github.io/raw/master/_posts/imgs/20200311-200726.png)

![](https://github.com/LLLibra/LLLibra.github.io/raw/master/_posts/imgs/20200311-200800.png)

#### 举个例子

![](https://github.com/LLLibra/LLLibra.github.io/raw/master/_posts/imgs/20200311-200827.png)


#### 一个问题
当一个唤醒线程唤醒了另一个线程，这时有两个线程，那么哪个先执行？

> #### Hansen方式
>
唤醒线程先执行，再执行唤醒的线程。（容易些）
因为不会第一时间执行唤醒的线程，所以再唤醒线程执行完的过程中可能有唤醒了多个线程。
>
所以给出了空闲信号后可能马上就被另一个唤醒的进程给用了，所以要用while

> #### Hoare方式
>
让唤醒的线程先执行，唤醒线程则睡眠。让唤醒的线程先执行。（直观但是实现复杂些）
因为第一时间会执行被唤醒的线程，所以生产者只需要判断一次，有空闲信号肯定给这个刚被唤醒的进程用。

>
![](https://github.com/LLLibra/LLLibra.github.io/raw/master/_posts/imgs/20200311-200959.png)
