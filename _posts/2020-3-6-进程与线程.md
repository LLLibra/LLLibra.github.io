---
layout: post
title:  "进程与线程"
data: 星期五, 06. 三月 2020 01:29下午 
categories: 操作系统
tags: 专题
---
* 该模块会针对操作系统中的某一块知识做专题整理，也许会有些不足或者错误的地方，未来可能会作修改。

#  操作系统专题1----进程与线程

* 本文会简单介绍一下进程和线程的概念与区别

## 进程

#### 什么是进程
进程是资源（CPU、内存等）分配的基本单位，它是程序执行时的一个实例。程序运行时系统就会创建一个进程，并为它分配资源，然后把该进程放入进程就绪队列，进程调度器选中它的时候就会为它分配CPU时间，程序开始真正运行。

**简单说进程是有独立功能的程序在一个数据集合上运行的过程，它是系统进行资源分配和调度的一个独立单位。**

#### 进程与程序
1.程序是进程的基础，程序每次运行构成不同的进程，进程是程序功能的体现。

2.通过多次执行，一个程序可以多个进程;通过调用


#### 进程的特点
**动态性：**可以动态地创建、结束进程

**并发性：**进程可以独立调度并占用处理机运行;并发并行

**独立性：**不同进程间工作互不影响

**制约性：**因访问共享数据/资源或进程间同步而产生制约


## 线程

#### 为什么需要线程
多进程的开销太大，进程间的通信和共享数据都是问题，而且维护进程的开销也大。所以就需要提出一种新的实体，可以并发执行，可以共享相同的地址空间。

#### 什么是线程
而线程是进程的组成部分，它代表了一条顺序的执行流。

线程=进程 - 共享资源

#### 线程的特点
1.可以共享资源

2.可以独立运行，并发运行

3.轻型实体：线程中的实体单位基本上不拥有系统资源，只是有一点必不可少的、能保证独立运行的资源。

#### 线程通信
1.共享内存

2.socket编程

#### 线程同步
1.信号量

2.互斥锁

3.管程


#### 注意事项
1.一个进程下的多个子线程均拥有自己独立的栈空间（存储函数参数、局部变量等）、寄存器、程序计数器和状态字，但是多个子线程和主线程共享堆、全局变量等**非栈内存**。

2.如果子线程的崩溃是由于自己的一亩三分地引起的，那就不会对主线程和其他子线程产生影响，但是如果子线程的崩溃是因为对共享区域造成了破坏，那么也会导致进程的崩溃。（但是查了资料子进程大部分都会引起主进程崩溃,如果屏蔽 segment fault 信号，且线程崩溃的位置是线程私有位置（stack），那么其他线程没有问题）

3.一个线程只能属于一个进程，而一个进程可以有多个线程，但至少有一个线程（通常说的主线程）。

4.一个线程可以创建和撤销另一个线程。

## 进程与线程的区别
1.进程是资源分配的最小单位，线程是程序执行的最小单位

2.进程切换开销大，线程切换开销小。
>
![](https://github.com/LLLibra/LLLibra.github.io/raw/master/_posts/imgs/20200314-194603.png)

2.线程之间的通信更方便，同一进程下的线程共享全局变量、静态变量等数据，而进程之间的通信需要以通信的方式（IPC)进行。

3.多进程程序更健壮，多线程程序只要有一个线程死掉，整个进程也死掉了，而一个进程死掉并不会对另外一个进程造成影响，因为进程有自己独立的地址空间。

4.进程有自己的独立地址空间，每启动一个进程，系统就会为它分配地址空间，建立数据表来维护代码段、堆栈段和数据段，这种操作非常昂贵。而线程是共享进程中的数据的，使用相同的地址空间，因此CPU切换一个线程的花费远比进程要小很多，同时创建一个线程的开销也比进程要小很多。

* 而是否共享地址空间几乎是进程和 Linux 中所谓线程的唯一区别。

>
一个进程/线程有两个堆栈：用户堆栈和内核堆栈。当进程/线程在用户空间中运行时，CPU堆栈指针寄存器里的内容是用户堆栈的地址；当进程/线程陷入内核态时，CPU堆栈指针寄存器的内容是内核堆栈的地址。
>
内核栈一般4K
>
从用户态转到内核态的时候，进程的内核栈总是空的


## 多线程与多进程

![](https://github.com/LLLibra/LLLibra.github.io/raw/master/_posts/imgs/20200306-142257.png)


需要频繁创建销毁、进行大量计算的优先使用多线程

强相关的处理用线程，弱相关的处理用进程（个人认为强相关的应该是需要经常切换的）

可能要扩展到多机分布的用进程，多核分布时也用进程

多线程模型适用于I/O密集型场景，因为I/O密集型场景因为I/O阻塞导致频繁切换

#### 多线程使用场景举例
1.与人有IO交互的应用，良好的用户体验（键盘鼠标的输入，立刻响应）

2.提供非均质的服务（有优先级任务处理）事件响应有优先级。

3.桌面软件，响应用户输入的是一个线程，后台程序处理是另外的线程； 
memcached

#### 多进程使用场景举例
1.nginx主流的工作模式是多进程模式（也支持多线程模型） 

2.几乎所有的web server服务器服务都有多进程的，chrome浏览器也是多进程方式

3.redis也可以归类到“多进程单线程”模型

## 多线程出现的原因
**充分利用CPU资源：**

单核CPU上所谓的”多线程”那是假的多线程，同一时间处理器只会处理一段逻辑，只不过线程之间切换得比较快，看着像多个线程”同时”运行罢了。多核CPU上的多线程才是真正的多线程，它能让你的多段逻辑同时工作，多线程，可以真正发挥出多核CPU的优势来，达到充分利用CPU的目的。

**防止阻塞：**
从程序运行效率的角度来看，单核CPU不但不会发挥出多线程的优势，反而会因为在单核CPU上运行多线程导致线程上下文的切换，而降低程序整体的效率。但是单核CPU我们还是要应用多线程，就是为了防止阻塞。试想，如果单核CPU使用单线程，那么只要这个线程阻塞了，比方说远程读取某个数据吧，对端迟迟未返回又没有设置超时时间，那么你的整个程序在数据返回回来之前就停止运行了。多线程可以防止这个问题，多条线程同时运行，哪怕一条线程的代码执行读取数据阻塞，也不会影响其它任务的执行。

## 多线程可能带来的问题
#### 可见性问题
简而言之，就是一个线程对另一个线程的操作结果能够立刻可见。（如果不可见会出现问题）

>
同一进程的多个线程可能位于不同CPU之上，而不同CPU各自拥有自己独立的缓存，但是会共用同一块主存。在实际运算时，CPU运算并不是直接操作主存地址上的变量的，而是读取主存变量到各自的缓存（即对于同一共享变量每个CPU都有各自的副本）。其中一个CPU上的线程不会主动将运行结果写回到主存，这样另一个CPU的线程读取主存变量的值还是没变，这就造成这个线程看不到另一个线程对同一个共享变量的操作变更。

**解决方法**对共享变量使用volatile修饰

#### 原子性问题
这个源于高级语言单条执行语句对应计算机一条执行指令的误解。实际上即使是一个自增操作对应到CPU指令有3条（读取初始值，CPU加1运算，写回运算结果值）。单个CPU指令运行是原子性的，不会被线程切换中断，但是高级语言的一条语句却对应多条CPU指令，就有可能被线程切换中断，导致彼线程来不及不知道此线程的运行结果的变化。

**解决方法：**加锁

#### 有序性问题
通俗来讲就是，代码并不一定会按照顺序来执行，java虚拟机在执行的过程中可能会改变顺序来提高性能，但是不会改变程序整体的运行结果。

**解决方法：**禁用编译器对这块代码的重排序优化，volatile修饰共享变量，final禁用对象初始化与赋值操作重排序，即确保新创建的对象在构造函数初始化完成后完成赋值给共享变量的操作。


## 减少多线程切的损耗换
1.避免创建过多的线程。如任务量少时，尽可能减少创建线程。对于某个时间段任务量很大的这种情况，我们可以通过线程池来管理线程的数量，避免创建过多线程。

2.协程：即协作式程序，其思想是，一系列互相依赖的协程间依次使用CPU，每次只有一个协程工作，而其他协程处于休眠状态。如：JAVA中使用wait和notify来达到线程之间的协同工作。



## 残留问题
什么时候选择用多进程，多进程容错率高，隔离性好，写程序不需要考虑太多内存锁之类的问题。



























