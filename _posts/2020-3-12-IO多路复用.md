---
layout: post
title:  "IO多路复用"
data: 星期四, 12. 三月 2020 10:50上午 
categories: 操作系统
tags: 专题
---
* 该模块会针对操作系统中的某一块知识做专题整理，也许会有些不足或者错误的地方，未来可能会作修改。

#  操作系统专题7----IO多路复用


## 为什么要IO多路复用
如果一个I/O流进来，我们就开启一个进程处理这个I/O流。那么假设现在有一百万个I/O流进来，那我们就需要开启一百万个进程一一对应处理这些I/O流（这就是传统意义下的多进程并发处理）。

但是这种方式明显不合理，所以有了IO多路复用的概念，** 一个线程，通过记录I/O流的状态来同时管理多个I/O，同时同时监听多个描述符。**

* IO多路复用有三种经典的实现方式select、poll和epoll

## 几个概念

#### 阻塞与非阻塞
阻塞和非阻塞通常用来形容多线程间的相互影响。一个线程占用了临
界区资源，那么其他所有需要这个资源的线程就必须在这个临界区中进行等待
等待会导致线程挂起，这种情况就是阻塞。此时，如果占用资源的线程一直不
愿意释放资源，那么其他所有阻塞在这个临界区上的线程都不能工作。

非阻塞的意思与之相反，它强调没有一个线程可以妨碍其他线程执行，所
有的线程都会尝试不断前向执行。


#### 同步与异步
 同步和异步通常用来形容一次方法调用。同步方法调用了就得等它返回，异步方法调用则可以继续其他的操作而不需要等待，之后会返回給调用者信息。

#### I/O操作

** IO分两阶段（一旦拿到数据后就变成了数据操作，不再是IO）：**
 
 1.数据准备阶段

 2.内核空间复制数据到用户进程缓冲区（用户空间）阶段

阻塞IO和非阻塞IO的区别在于第一步发起IO请求是否会被阻塞

同步IO和异步IO的区别就在于第二个步骤是否阻塞，阻塞即为同步，不阻塞即为异步。


![](https://github.com/LLLibra/LLLibra.github.io/raw/master/_posts/imgs/20200312-142610.png)

## Select
#### 时间复杂度
O(n)


#### 数据结构 fd_set

fd_set是一个bitmap

![](https://github.com/LLLibra/LLLibra.github.io/raw/master/_posts/imgs/20200312-110242.png)

bitmap就是一串的0,我们的描述符有编号（从0开始），假设我们要监听的描述符编号为1、3、5,并且1号和3号有对应的信号传来,那么我们的bitmap中第2、4的0会被置为1（第一位对应编号为0）,表示我们在监听。最多是1024位。

#### select函数
![](https://github.com/LLLibra/LLLibra.github.io/raw/master/_posts/imgs/20200312-111603.png)
>
nfds表示最大的描述符编号+1，不超过1024
> 
三个fd_set集合，分别代表三种事件，readfds表示读描述符集合，writefds表示读描述符集合, exceptfds表示描述符错误检查集合
>
![](https://github.com/LLLibra/LLLibra.github.io/raw/master/_posts/imgs/20200312-112352.png)

* select函数返回产生事件的描述符的数量，如果为-1表示产生错误

* 注意每次调用select函数，三个fd_set函数都被初始化过了。

#### 过程代码
![](https://github.com/LLLibra/LLLibra.github.io/raw/master/_posts/imgs/20200312-111123.png)


## Poll
#### 时间复杂度
O(n)


#### 数据结构
使用结构体代替bitmap

![](https://github.com/LLLibra/LLLibra.github.io/raw/master/_posts/imgs/20200312-112835.png)

events起到了标识需要监听是读还是写事件，还是都需要

revents起到的作用则是将bitmap置1一样的作用，触发标识符。

#### Poll函数
![](https://github.com/LLLibra/LLLibra.github.io/raw/master/_posts/imgs/20200312-112734.png)

>
传入三个参数
>
poolfd结构体链表
>
fds同上面select的nfds
>
![](https://github.com/LLLibra/LLLibra.github.io/raw/master/_posts/imgs/20200312-113120.png)


* poll函数返回产生事件的描述符的数量，如果返回0表示超时，如果为-1表示产生错误

#### 过程代码
![](https://github.com/LLLibra/LLLibra.github.io/raw/master/_posts/imgs/20200312-111141.png)


## Epoll
#### 时间复杂度
O(1)


#### 数据结构

![](https://github.com/LLLibra/LLLibra.github.io/raw/master/_posts/imgs/20200312-114820.png)

events表示要监听的事件

> ### Epoll 的两种工作模式
> #### LT模式(水平触发)
>
若就绪的事件一次没有处理完要做的事件，就会一直去处理。即就会将没有处理完的事件继续放回到就绪队列之中（即那个内核中的链表），一直进行处理。 
> #### ET模式(边缘触发5)
>
就绪的事件只能处理一次，若没有处理完会在下次的其它事件就绪时再进行处理。而若以后再也没有就绪的事件，那么剩余的那部分数据也会随之而丢失。(ET模式只支持非阻塞的读写：为了保证数据的完整性。) 
>  
由此可见：ET模式的效率比LT模式的效率要高很多。只是如果使用ET模式，就要保证每次进行数据处理时，要将其处理完，不能造成数据丢失，这样对编写代码的人要求就比较高。 

#### epoll_create
![](https://github.com/LLLibra/LLLibra.github.io/raw/master/_posts/imgs/20200312-115118.png)

应该是创建一个结构体数组

#### epoll_ctl 
为 epoll_create 返回的结构体数组注册要监听的数据

注册要监听的事件类型

同时将时间放入就绪队列（链表）中

![](https://github.com/LLLibra/LLLibra.github.io/raw/master/_posts/imgs/20200312-115346.png)

![](https://github.com/LLLibra/LLLibra.github.io/raw/master/_posts/imgs/20200312-115507.png)

#### epoll_wait（主函数）判断就绪队列（链表）中是否有事件

![](https://github.com/LLLibra/LLLibra.github.io/raw/master/_posts/imgs/20200312-115605.png)

epoll_wait类似与select中的select函数、poll中的poll函数，等待内核返回监听描述符的事件产生

>
__epfd是epoll_create创建的epoll实例
>
events数组为epoll_wait要返回的已经产生的事件集合，其中第i个元素成员的__events[i]->data->fd表示产生该事件的描述符
>
maxevents为希望返回的最大的事件数量（通常为__events的大小）
>
timeout和poll中的timeout相同

* 该函数返回已经就绪的事件的数量，如果为-1表示出错。

#### 过程代码
![](https://github.com/LLLibra/LLLibra.github.io/raw/master/_posts/imgs/20200312-111148.png)


## Select、Poll和Epoll对比
#### Select
首先讲Select，Select的监听是直接从用户态转换到内核态，等到监听到事件或者时间到才能切换回去。

poll还有一个特点是“水平触发”，如果报告了fd后，没有被处理，那么下次poll时会再次报告该fd。

#### Select的优点
1、select的可移植性更好，在某些Unix系统上不支持poll()。

2、select对于超时值提供了更好的精度：微秒，而poll是毫秒。

#### Select的缺点
1.bitmap支持的文件描述符最多也就1024.

2.由于每次要进入内核态判断，内核态和用户态的的切换开销很大

3.在函数调用返回后轮询查找哪个文件描述符被标记。

#### Poll
poll本质上和select没有区别，它将用户传入的数组拷贝到内核空间，然后查询每个fd对应的设备状态，如果设备就绪则在设备等待队列中加入一项并继续遍历。

#### Poll的优点
1.解除了1024的限制

2.poll() 在应付大数目的文件描述符的时候速度更快，相比于select。

3.使用的结构体里的revents用来做标记，每次处理该事件又将该标记清零，解决了Select 里rset每次都要重置的缺点。

#### Poll的缺点
1.同样需要解决内核态和用户态切换开销太大的问题

2.同样需要在函数调用返回后轮询查找哪个文件描述符被标记。

#### Epoll

不同于前两者只有一个函数可以调用，epoll提供了三个函数，epoll_create是创建一个epoll句柄；epoll_ctl是注册要监听的事件类型；epoll_wait则是等待事件的产生。

#### Epoll的优化

1.对于不停地往内核态复制数据，耗费很多时间的问题，epoll的解决方案在epoll_ctl函数中。每次注册新的事件到epoll句柄中时，会把所有的fd拷贝进内核，保证了每个fd在整个过程中只会拷贝一次。

2.对于select和poll每次调用完函数都要遍历的缺点，epoll的解决方案不像select或poll一样每次都把current轮流加入fd对应的设备等待队列中，而只在epoll_ctl时把current挂一遍（这一遍必不可少）并为每个fd指定一个回调函数，当设备就绪，唤醒等待队列上的等待者时，就会调用这个回调函数，而这个回调函数会把就绪的fd加入一个就绪链表）。epoll_wait的工作实际上就是在这个就绪链表中查看有没有就绪的fd





































