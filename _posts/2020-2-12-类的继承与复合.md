---
layout: post
title:  "类的继承与复合"
data: 星期三, 12. 二月 2020 03:44下午 
categories: C++
tags: 专题
---
* 该模块会针对C++中的某一块知识做专题整理，也许会有些不足或者错误的地方，未来可能会作修改。

# C++专题2----类的继承与复合

## 前言
类的继承，最简单分为三类，public、protected、private三种，而后复杂一些出现多继承，随后菱形继承或者说虚继承，又有一些时候我们不会选择继承的方式，而是采用复合的方式来帮助类的实现。而本篇文章就是想介绍一下里面的区别和特点。

## 三种常规的继承方式与多继承
**格式：**

class Derive: public Base

class Derive: public Base1, public Base2 

**继承规则：**

![](https://github.com/LLLibra/LLLibra.github.io/raw/master/_posts/imgs/20200212-161639.png)

**注意事项：**

1.对于基类，派生类对象只能访问public成员和protected成员，不能访问private成员，所以只有public继承可以让我们把派生类顺利转化为基类。派生类对象向基类的自动转换类型只针对引用或指针类型有效，对象之间不存在类型转换。

2.无论派生类对于基类的继承方式是什么 , 派生类的成员和友元永远都有对于基类的的保护成员和公有成员的访问权限。

3.如果D继承B的方式是公有或者受保护，则**D的派生类**的成员和友元有对B的公有和保护成员的访问权限,反之，如果D继承B的方式是私有的则不能使用。

**注意2 3中的主语是派生类，而1的主语是派生类对象**

4.友元的关系并不能继承。基类的友元访问派生类不具特殊性，类似，派生类的友元也不能随意访问基类成员。(注意如果是公有和保护继承，友元还是能访问公有和保护成员的)

5.当父类有显式地声明了构造函数时，子类最低限度的实现父类中的一个；当父类没有声明构造函数时，子类可以不声明构造函数或者任意地书写构造函数。

## 虚继承（菱形继承问题）
**用以解决多个基类有一个公共基类或者多重继承中有重名函数的问题。**
 
 我们可以看见Panda的对象模型里面保存了两份ZooAnimal,当我们想要调用我们从ZooAnimal里继承的函数时就会出现调用不明确问题，并且会造成数据冗余的问题，明明可以只要一份就好，而我们却保存了两份。

![](https://github.com/LLLibra/LLLibra.github.io/raw/master/_posts/imgs/20200212-163439.png)

派生类可以通过它的两个直接基类分别继承同一个间接基类，也可以直接继承某个基类，然后在通过另一个基类再一次间接继承基类。而这样就出现一个类有多个同一基类，而使用虚基类就可以将这种多个变为一个。

**格式：**

![](https://github.com/LLLibra/LLLibra.github.io/raw/master/_posts/imgs/20200212-163302.png)



1.virtual说明了后续派生类当中将会共享一份虚基类，这时派生类就不是保存改基类的内容，而是偏移地址，然后将基类的数据保存在一个公共位置，降低了数据冗余性。

2.含有虚基类的对象的构造顺序与一般的顺序稍有区别，首先使用提供给最底层派生构造函数的初始值初始化该对象的虚基类子部分，接下来按照直接基类在派生列表中出现的次序依次对其进行初始化。需要**显式初始化**。销毁顺序和构造顺序相反。
>
这一点我解释一下，就比如B虚继承了A，C普通继承了B，同时A重新了自己的构造函数比如A(int x){}; ,这时B和C都需要重写构造函数，B():A(22){}; 和 C():A(33){};，即之后的继承体系里A都要显式构造。

3.很重要的一点，一个类一旦被虚继承，那么所有继承它的类最好都使用虚继承。

![](https://github.com/LLLibra/LLLibra.github.io/raw/master/_posts/imgs/20200212-170533.png)

3.假设ZooAnimal中有一个a成员，Panda要访问Bear的a，则方式为Panda.Bear::a.

**问题：**所以虽然使用虚继承解决数据冗余问题也带来了性能上的损耗

## 注意事项：
1.有一种防止继承发生的方法，即在类名后跟一个关键字final

2.有时候需要改变派生类继承某个基类成员的访问级别，通过using声明

3.派生类的成员将隐藏同名的基类成员，但不建议这么做，具体看我的Effective C++ 板块。

## 残留问题：
对于虚继承，派生类是如何区分多个虚基类中的普通重名函数成员。







