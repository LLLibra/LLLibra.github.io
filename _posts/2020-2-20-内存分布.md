---
layout: post
title:  "内存分布"
data: 星期四, 20. 二月 2020 04:56下午 
categories: C++
tags: 专题
---
* 该模块会针对C++中的某一块知识做专题整理，也许会有些不足或者错误的地方，未来可能会作修改。

# C++专题5----内存分布

本篇博文主要是总结一下C++中的内存分布。

## 内存分区
**一个C/C++编译的程序占用内存分为以下几个部分：**

#### 栈区（stack）：
由编译器自动分配与释放，存放为运行时函数分配的局部变量、函数参数、返回数据、返回地址等。其操作类似于数据结构中的栈。

在windows平台下，栈的大小的信息是包含在可执行文件中的。它可以在Visual C++的编译过程中设置，但是在gcc中是不可行的。

在Unix-like平台，栈的大小不是由程序自己来控制的而是由环境变量来控制的，所以就不能通过设置编译器（像gcc)的任何编译标志来设置栈的大小



#### 堆区（heap）：
一般由程序员自动分配，如果程序员没有释放，程序结束时可能有OS回收。其分配类似于链表。

#### 全局区（静态存储区）(数据段)：
存放全局变量、静态数据、常量。程序结束后由系统释放。全局区分为已初始化全局区（data）和未初始化全局区（bss）。



#### 常量区（文字常量区）：
存放常量字符串，程序结束后有系统释放。

#### 代码区：(只读)
存放函数体（类成员函数和全局区）的二进制代码。


### 内存分配图

![](https://github.com/LLLibra/LLLibra.github.io/raw/master/_posts/imgs/20200220-173033.png)

![](https://github.com/LLLibra/LLLibra.github.io/raw/master/_posts/imgs/20200221-191525.png)

## 内存分配方式

#### 从静态存储区分配
内存在程序编译的时候已经分配好，这块内存在程序的整个运行期间都存在。例如全局变量，static变量。

#### 在栈上创建
在执行函数时，函数内局部变量的存储单元可以在栈上创建，函数执行结束时，这些内存单元会自动被释放。
栈内存分配运算内置于处理器的指令集，效率高，但是分配的内存容量有限。


#### 从堆上分配
亦称为动态内存分配。

程序在运行的时候使用malloc或者new申请任意多少的内存，程序员自己负责在何时用free或delete释放内存。
动态内存的生命周期有程序员决定，使用非常灵活，但如果在堆上分配了空间，既有责任回收它，否则运行的程序会出现内存泄漏，频繁的分配和释放不同大小的堆空间将会产生内存碎片。

## 堆和栈的区别
**管理方式不同：**栈是由编译器自动申请和释放空间，堆是需要程序员手动申请和释放；

**空间大小不同：** **栈**的空间是有限的，在32位平台下，VC6下默认为1M，是一块连续的内存区域，栈顶的地址和栈的最大容量是系统预先规定好的，能从栈获得的空间较小。**堆**是不连续的内存区域，这是由于系统是由链表在存储空闲内存地址，自然堆就是不连续的内存区域，且链表的遍历也是从低地址向高地址遍历的，堆得大小受限于计算机系统的有效虚拟内存空间，由此空间，堆获得的空间比较灵活，也比较大。，堆最大可	以到4G；

**能否产生碎片：**栈和数据结构中的栈原理相同，在弹出一个元素之前，上一个已经弹出了，不会产生碎片，但是不论是堆还是栈，如果不停地调用malloc、free对造成内存碎片很多；

**生长方向不同：**堆生长方向是向上的，也就是向着内存地址增加的方向，栈刚好相反，向着内存减小的方向生长。

**分配方式不同：**堆都是动态分配的，没有静态分配的堆。栈有静态分配和动态分配。静态分配是编译器完成的，比如局部变量的分配。动态分配由 malloc 函数进行分配，但是栈的动态分配和堆是不同的，它的动态分配是由编译器进行释放，无需我们手工实现。

**分配效率不同：**栈的效率比堆高很多。栈是机器系统提供的数据结构，计算机在底层提供栈的支持，分配专门的寄存器来存放栈的地址，压栈出栈都有相应的指令，因此比较快。堆是由库函数提供的，机制很复杂，库函数会按照一定的算法进行搜索内存，因此比较慢。
>
同时堆是用的时候才向系统申请的，用完了还回去，这个申请和交还的过程开销相对就比较大了。



#### 限制类只能建立在堆上
将析构函数设为私有，类对象就无法建立在栈上了。

最好设置为protected，不然无法作为基类了。

## 静态全局变量、全局变量、静态局部变量、局部变量

#### 作用域和初始化（未赋值）
全局变量在整个工程文件内都有效，全局变量只需在一个源文件中定义，就可以作用于所有的源文件。当然，其他不包含全局变量定义的源文件需要用extern 关键字再次声明这个全局变量。初始化为0.

普通局部变量只在定义它的函数内有效，**初始化为随机值**。

静态全局变量只在定义它的文件内有效，初始化为0。全局变量、文件域的静态变量和类的静态成员变量在main执行之前的静态初始化过程中分配内存并初始化

静态局部变量只在定义它的函数内有效，且程序仅分配一次内存**(局部静态变量只会定义一次,在第一次使用时分配内存并初始化)**，函数返回后，该变量不会消失；局部变量在定义它的函数内有效，但是函数返回后失效。初始化为0。

* C语言中的静态变量则是一直在编译期就初始化分配内存
#### 内存分配
全局变量，静态局部变量，静态全局变量都在静态存储区分配空间（全局区），局部变量在栈里分配空间

#### 注意点：

定义静态全局变量还有以下好处： （只在本文件作用域内有效）
1.静态全局变量不能被其它文件所用；
2.其它文件中可以定义相同名字的变量，不会发生冲突；

虽然静态局部变量看似没用，但是有函数中必须要使用static变量情况:比如当某函数的返回值为指针类型时，则必须是static的局部变量的地址作为返回值，若为auto类型，则返回为错指针。

如果我们需要一个可重入的函数，那么，我们一定要避免函数中使用static变量。（可被多个任务同时调用的就是可重入函数。）
>
不可重入函数多数满足下列条件
>
（1）函数体内使用了静态的数据结构；
>
（2）函数体内调用了malloc()或者free()函数；
>
（3）函数体内调用了标准I/O函数。
























