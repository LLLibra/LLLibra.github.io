---
layout: post
title:  "内存分布"
data: 星期四, 20. 二月 2020 04:56下午 
categories: C++
tags: 专题
---
* 该模块会针对C++中的某一块知识做专题整理，也许会有些不足或者错误的地方，未来可能会作修改。

# C++专题5----内存分布

本篇博文主要是总结一下C++中的内存分布。

## 内存分区
**一个C/C++编译的程序占用内存分为以下几个部分：**

#### 栈区（stack）：
由编译器自动分配与释放，存放为运行时函数分配的局部变量、函数参数、返回数据、返回地址等。其操作类似于数据结构中的栈。

在windows平台下，栈的大小的信息是包含在可执行文件中的。它可以在Visual C++的编译过程中设置，但是在gcc中是不可行的。

在Unix-like平台，栈的大小不是由程序自己来控制的而是由环境变量来控制的，所以就不能通过设置编译器（像gcc)的任何编译标志来设置栈的大小



#### 堆区（heap）：
一般由程序员自动分配，如果程序员没有释放，程序结束时可能有OS回收。其分配类似于链表。

#### 全局区（静态存储区）(数据段)：
存放全局变量、静态数据、常量。程序结束后由系统释放。全局区分为已初始化全局区（data）和未初始化全局区（bss）。

#### 常量区（文字常量区）：
存放常量字符串，程序结束后有系统释放。

#### 代码区：
存放函数体（类成员函数和全局区）的二进制代码。


### 内存分配图

![](https://github.com/LLLibra/LLLibra.github.io/raw/master/_posts/imgs/20200220-173033.png)

![](https://github.com/LLLibra/LLLibra.github.io/raw/master/_posts/imgs/20200221-191525.png)

## 内存分配方式

#### 从静态存储区分配
内存在程序编译的时候已经分配好，这块内存在程序的整个运行期间都存在。例如全局变量，static变量。

#### 在栈上创建
在执行函数时，函数内局部变量的存储单元可以在栈上创建，函数执行结束时，这些内存单元会自动被释放。
栈内存分配运算内置于处理器的指令集，效率高，但是分配的内存容量有限。


#### 从堆上分配
亦称为动态内存分配。

程序在运行的时候使用malloc或者new申请任意多少的内存，程序员自己负责在何时用free或delete释放内存。
动态内存的生命周期有程序员决定，使用非常灵活，但如果在堆上分配了空间，既有责任回收它，否则运行的程序会出现内存泄漏，频繁的分配和释放不同大小的堆空间将会产生内存碎片。

## 堆和栈的区别
**管理方式不同：**栈是由编译器自动申请和释放空间，堆是需要程序员手动申请和释放；

**空间大小不同：****栈**的空间是有限的，在32位平台下，VC6下默认为1M，是一块连续的内存区域，栈顶的地址和栈的最大容量是系统预先规定好的，能从栈获得的空间较小。**堆**是不连续的内存区域，这是由于系统是由链表在存储空闲内存地址，自然堆就是不连续的内存区域，且链表的遍历也是从低地址向高地址遍历的，堆得大小受限于计算机系统的有效虚拟内存空间，由此空间，堆获得的空间比较灵活，也比较大。，堆最大可	以到4G；

**能否产生碎片：**栈和数据结构中的栈原理相同，在弹出一个元素之前，上一个已经弹出了，不会产生碎片，但是不论是堆还是栈，如果不停地调用malloc、free对造成内存碎片很多；

**生长方向不同：**堆生长方向是向上的，也就是向着内存地址增加的方向，栈刚好相反，向着内存减小的方向生长。

**分配方式不同：**堆都是动态分配的，没有静态分配的堆。栈有静态分配和动态分配。静态分配是编译器完成的，比如局部变量的分配。动态分配由 malloc 函数进行分配，但是栈的动态分配和堆是不同的，它的动态分配是由编译器进行释放，无需我们手工实现。

**分配效率不同：**栈的效率比堆高很多。栈是机器系统提供的数据结构，计算机在底层提供栈的支持，分配专门的寄存器来存放栈的地址，压栈出栈都有相应的指令，因此比较快。堆是由库函数提供的，机制很复杂，库函数会按照一定的算法进行搜索内存，因此比较慢。

##  动态内存
#### 动态内存分配命令
**malloc：**申请指定字节数的内存。申请到的内存中的初始值不确定。

**calloc：**为指定长度的对象，分配能容纳其指定个数的内存。申请到的内存的每一位（bit）都初始化为 0。

**realloc：**更改以前分配的内存长度（增加或减少）。当增加长度时，可能需将以前分配区的内容移到另一个足够大的区域，而新增区域内的初始值则不确定。

**alloca：**在栈上申请内存。程序在出栈的时候，会自动释放内存。但是需要注意的是，alloca 不具可移植性, 而且在没有传统堆栈的机器上很难实现。alloca 不宜使用在必须广泛移植的程序中。C99 中支持变长数组 (VLA)，可以用来替代 alloca。

#### malloc底层原理
1）当开辟的空间小于 128K 时，调用 brk（）函数，malloc 的底层实现是系统调用函数**brk（）**，其主要移动指针 _enddata(此时的 _enddata 指的是 Linux 地址空间中堆段的末尾地址，不是数据段的末尾地址)
>brk 是将数据段（.data）的最高地址指针 _edata 往高地址推
>
![](https://github.com/LLLibra/LLLibra.github.io/raw/master/_posts/imgs/20200409-115751.png)
>
事实是：_edata+30K只是完成虚拟地址的分配，A这块内存现在还是没有物理页与之对应的，等到进程第一次读写A这块内存的时候，发生缺页中断，这个时候，内核才分配A这块内存对应的物理页。也就是说，如果用malloc分配了A这块内容，然后从来不访问它，那么，A对应的物理页是不会被分配的。


2）当开辟的空间大于 128K 时，**mmap（）**系统调用函数来在虚拟地址空间中（堆和栈中间，称为“文件映射区域”的地方）找一块空间来开辟。
>mmap 是在进程的虚拟地址空间中（堆和栈中间，称为“文件映射区域”的地方）找一块空闲的虚拟内存。
>
![](https://github.com/LLLibra/LLLibra.github.io/raw/master/_posts/imgs/20200409-115628.png)

这两种方式分配的都是虚拟内存，没有分配物理内存。

> #### 为什么要分情况分配呢
>
brk分配的内存需要等到高地址内存释放以后才能释放（例如，在B释放之前，A是不可能释放的，因为只有一个_edata 指针，这就是内存碎片产生的原因，什么时候紧缩看下面），而mmap分配的内存可以单独释放。
>
当然这个B被释放了，还是能重用的
>
![](https://github.com/LLLibra/LLLibra.github.io/raw/master/_posts/imgs/20200409-120130.png)

>
当最高地址空间的空闲内存超过128K（可由M_TRIM_THRESHOLD选项调节）时，执行内存紧缩操作（trim）。在上一个步骤free的时候，发现最高地址空闲内存超过128K，于是内存紧缩，变成图9所示


malloc函数的实质体现在，它有一个将可用的内存块连接为一个长长的列表的所谓空闲链表。调用malloc函数时，它沿连接表寻找一个大到足以满足用户请求所需要的内存块。然后，将该内存块一分为二（一块的大小与用户请求的大小相等，另一块的大小就是剩下的字节）。接下来，将分配给用户的那块内存传给用户，并将剩下的那块（如果有的话）返回到连接表上。调用free函数时，它将用户释放的内存块连接到空闲链上。到最后，空闲链会被切成很多的小内存片段，如果这时用户申请一个大的内存片段，那么空闲链上可能没有可以满足用户要求的片段了。于是，malloc函数请求延时，并开始在空闲链上翻箱倒柜地检查各内存片段，对它们进行整理，将相邻的小空闲块合并成较大的内存块。 


#### new、delete
**new / new[]：**完成两件事，先底层调用 malloc 分配了内存，然后调用构造函数（创建对象）。
>
![](https://github.com/LLLibra/LLLibra.github.io/raw/master/_posts/imgs/20200401-135715.png)

**delete/delete[]：**也完成两件事，先调用析构函数（清理资源），然后底层调用 free 释放空间。

new 在申请内存时会自动计算所需字节数，而 malloc 则需我们自己输入申请内存空间的字节数。

相应的，delete也有delete operator和operator delete之分，后者也是可以重载的。并且，如果重载了operator new，就应该也相应的重载operator delete，这是良好的编程习惯。

**operator new(可以重载)**
>
new运算符将对象建立在堆空间中。这个过程分为两步，第一步是执行operator new()函数，在堆空间中搜索合适的内存并进行分配；第二步是调用构造函数构造对象，初始化这片内存空间。
>
operator new中包含了malloc函数
>
new的执行过程
>
1.调用operator new分配内存 ；
>
2.调用构造函数生成类对象；
>
3.返回相应指针。

**placement new**
>
允许你在一个已经分配好的内存中（栈或者堆中）构造一个新的对象。
>
重载全局的operator new之后，new函数的操作就被改变了。也就能猜出，在调用new的时候参数需要加上一个地址，placement new的功能就是在这个地址之上进行构造。
>
placement new是用来实现定位构造的，因此可以实现new operator三步操作中的第二步，也就是在取得了一块可以容纳指定类型对象的原始内存后，在这块内存上构造出一个对象 
>
![](https://github.com/LLLibra/LLLibra.github.io/raw/master/_posts/imgs/20200322-222844.png)
>
它实现了在指定的内存地址上调用制定类型的构造函数去构造一个对象的功能
>
另一个例子
>
![](https://github.com/LLLibra/LLLibra.github.io/raw/master/_posts/imgs/20200401-141256.png)

#### new最多能分配多少内存/new如何扩充内存
单纯的new是不会实际占用内存空间的，只要等到真正的用到时才会占用内存空间。

new最大空间大小 = 操作系统剩余内存大小 + 操作系统剩余交换分区大小（虚拟内存）

* 不能原地扩容 除非用maclloc realloc，那是C的方法，也可以考虑memcpy和vector

#### malloc/new、free/delete的异同
malloc/free是C/C++标准库的函数，new/delete是C++操作符。

![](https://github.com/LLLibra/LLLibra.github.io/raw/master/_posts/imgs/20200221-184637.png)

>
两点注意：
>
（1）对于用户自定义的对象而言，用maloc/free无法满足动态管理对象的要求。对象在创建的同时要自动执行构造函数，对象在消亡之前要自动执行析构函数。由于malloc/free是库函数而不是运算符，不在编译器控制权限之内，不能够把执行构造函数和析构函数的任务强加于malloc/free。因此C++需要一个能完成动态内存分配和初始化工作的运算符new，以及一个能完成清理与释放内存工作的运算符delete。
>>
具体调用是，new分配内存时，先调用malloc后调用构造函数，释放空间时，先调用析构函数，后调用free。
>
(2)既然new/delete的功能完全覆盖了malloc/free，为什么C++还保留malloc/free呢？
>>
因为C++程序经常要调用C函数，而C程序只能用malloc/free管理动态内存。如果用free释放“new创建的动态对象”，那么该对象因无法执行析构函数而可能导致程序出错。如果用delete释放“malloc申请的动态内存”，理论上讲程序不会出错，但是该程序的可读性很差。所以new/delete、malloc/free必须配对使用。
>
(3)malloc（0）返回一个合法的指针并指向存储内存块信息的额外内存,并不会返回一个空指针

#### 限制类只能建立在堆上
将析构函数设为私有，类对象就无法建立在栈上了。

最好设置为protected，不然无法作为基类了。

## 静态全局变量、全局变量、静态局部变量、局部变量

#### 作用域和初始化（未赋值）
全局变量在整个工程文件内都有效，全局变量只需在一个源文件中定义，就可以作用于所有的源文件。当然，其他不包含全局变量定义的源文件需要用extern 关键字再次声明这个全局变量。初始化为0.

普通局部变量只在定义它的函数内有效，**初始化为随机值**。

静态全局变量只在定义它的文件内有效，初始化为0。全局变量、文件域的静态变量和类的静态成员变量在main执行之前的静态初始化过程中分配内存并初始化

静态局部变量只在定义它的函数内有效，且程序仅分配一次内存**(局部静态变量只会定义一次,在第一次使用时分配内存并初始化)**，函数返回后，该变量不会消失；局部变量在定义它的函数内有效，但是函数返回后失效。初始化为0。

* C语言中的静态变量则是一直在编译期就初始化分配内存
#### 内存分配
全局变量，静态局部变量，静态全局变量都在静态存储区分配空间（全局区），局部变量在栈里分配空间

#### 注意点：

定义静态全局变量还有以下好处： （只在本文件作用域内有效）
1.静态全局变量不能被其它文件所用；
2.其它文件中可以定义相同名字的变量，不会发生冲突；

虽然静态局部变量看似没用，但是有函数中必须要使用static变量情况:比如当某函数的返回值为指针类型时，则必须是static的局部变量的地址作为返回值，若为auto类型，则返回为错指针。

如果我们需要一个可重入的函数，那么，我们一定要避免函数中使用static变量。（可被多个任务同时调用的就是可重入函数。）
>
不可重入函数多数满足下列条件
>
（1）函数体内使用了静态的数据结构；
>
（2）函数体内调用了malloc()或者free()函数；
>
（3）函数体内调用了标准I/O函数。
