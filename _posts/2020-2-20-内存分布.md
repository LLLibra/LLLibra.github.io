---
layout: post
title:  "内存分布"
data: 星期四, 20. 二月 2020 04:56下午 
categories: C++
tags: 专题
---
* 该模块会针对C++中的某一块知识做专题整理，也许会有些不足或者错误的地方，未来可能会作修改。

# C++专题5----内存分布

本篇博文主要是总结一下C++中的内存分布。

## 内存分区
** 一个C/C++编译的程序占用内存分为以下几个部分：**

#### 栈区（stack）：
由编译器自动分配与释放，存放为运行时函数分配的局部变量、函数参数、返回数据、返回地址等。其操作类似于数据结构中的栈。

#### 堆区（heap）：
一般由程序员自动分配，如果程序员没有释放，程序结束时可能有OS回收。其分配类似于链表。

#### 全局区（静态存储区）(数据段)：
存放全局变量、静态数据、常量。程序结束后由系统释放。全局区分为已初始化全局区（data）和未初始化全局区（bss）。

#### 常量区（文字常量区）：
存放常量字符串，程序结束后有系统释放。

#### 代码区：
存放函数体（类成员函数和全局区）的二进制代码。

### 内存分配图

![](https://github.com/LLLibra/LLLibra.github.io/raw/master/_posts/imgs/20200220-173033.png)

![](https://github.com/LLLibra/LLLibra.github.io/raw/master/_posts/imgs/20200221-191525.png)

## 内存分配方式

#### 从静态存储区分配
内存在程序编译的时候已经分配好，这块内存在程序的整个运行期间都存在。例如全局变量，static变量。

#### 在栈上创建
在执行函数时，函数内局部变量的存储单元可以在栈上创建，函数执行结束时，这些内存单元会自动被释放。
栈内存分配运算内置于处理器的指令集，效率高，但是分配的内存容量有限。


#### 从堆上分配
亦称为动态内存分配。

程序在运行的时候使用malloc或者new申请任意多少的内存，程序员自己负责在何时用free或delete释放内存。
动态内存的生命周期有程序员决定，使用非常灵活，但如果在堆上分配了空间，既有责任回收它，否则运行的程序会出现内存泄漏，频繁的分配和释放不同大小的堆空间将会产生内存碎片。

## 堆和栈的区别
** 管理方式不同：** 栈是由编译器自动申请和释放空间，堆是需要程序员手动申请和释放；

** 空间大小不同：** **栈**的空间是有限的，在32位平台下，VC6下默认为1M，是一块连续的内存区域，栈顶的地址和栈的最大容量是系统预先规定好的，能从栈获得的空间较小。** 堆 **是不连续的内存区域，这是由于系统是由链表在存储空闲内存地址，自然堆就是不连续的内存区域，且链表的遍历也是从低地址向高地址遍历的，堆得大小受限于计算机系统的有效虚拟内存空间，由此空间，堆获得的空间比较灵活，也比较大。，堆最大可	以到4G；

** 能否产生碎片：**栈和数据结构中的栈原理相同，在弹出一个元素之前，上一个已经弹出了，不会产生碎片，但是不论是堆还是栈，如果不停地调用malloc、free对造成内存碎片很多；

** 生长方向不同：**堆生长方向是向上的，也就是向着内存地址增加的方向，栈刚好相反，向着内存减小的方向生长。

** 分配方式不同：**堆都是动态分配的，没有静态分配的堆。栈有静态分配和动态分配。静态分配是编译器完成的，比如局部变量的分配。动态分配由 malloc 函数进行分配，但是栈的动态分配和堆是不同的，它的动态分配是由编译器进行释放，无需我们手工实现。

** 分配效率不同：**栈的效率比堆高很多。栈是机器系统提供的数据结构，计算机在底层提供栈的支持，分配专门的寄存器来存放栈的地址，压栈出栈都有相应的指令，因此比较快。堆是由库函数提供的，机制很复杂，库函数会按照一定的算法进行搜索内存，因此比较慢。

##  动态内存
#### 动态内存分配命令
** malloc：**申请指定字节数的内存。申请到的内存中的初始值不确定。

** calloc：**为指定长度的对象，分配能容纳其指定个数的内存。申请到的内存的每一位（bit）都初始化为 0。

** realloc：**更改以前分配的内存长度（增加或减少）。当增加长度时，可能需将以前分配区的内容移到另一个足够大的区域，而新增区域内的初始值则不确定。

** alloca：**在栈上申请内存。程序在出栈的时候，会自动释放内存。但是需要注意的是，alloca 不具可移植性, 而且在没有传统堆栈的机器上很难实现。alloca 不宜使用在必须广泛移植的程序中。C99 中支持变长数组 (VLA)，可以用来替代 alloca。

#### new、delete
** new / new[]：**完成两件事，先底层调用 malloc 分配了内存，然后调用构造函数（创建对象）。

** delete/delete[]：**也完成两件事，先调用析构函数（清理资源），然后底层调用 free 释放空间。

new 在申请内存时会自动计算所需字节数，而 malloc 则需我们自己输入申请内存空间的字节数。

#### malloc/new、free/delete的异同
malloc/free是C/C++标准库的函数，new/delete是C++操作符。

![](https://github.com/LLLibra/LLLibra.github.io/raw/master/_posts/imgs/20200221-184637.png)

>
两点注意：
>
（1）对于用户自定义的对象而言，用maloc/free无法满足动态管理对象的要求。对象在创建的同时要自动执行构造函数，对象在消亡之前要自动执行析构函数。由于malloc/free是库函数而不是运算符，不在编译器控制权限之内，不能够把执行构造函数和析构函数的任务强加于malloc/free。因此C++需要一个能完成动态内存分配和初始化工作的运算符new，以及一个能完成清理与释放内存工作的运算符delete。
>>
具体调用是，new分配内存时，先调用malloc后调用构造函数，释放空间时，先调用析构函数，后调用free。
>
既然new/delete的功能完全覆盖了malloc/free，为什么C++还保留malloc/free呢？
>>
因为C++程序经常要调用C函数，而C程序只能用malloc/free管理动态内存。如果用free释放“new创建的动态对象”，那么该对象因无法执行析构函数而可能导致程序出错。如果用delete释放“malloc申请的动态内存”，理论上讲程序不会出错，但是该程序的可读性很差。所以new/delete、malloc/free必须配对使用。



## 静态全局变量、全局变量、静态局部变量、局部变量

#### 作用域和初始化（未赋值）
全局变量在整个工程文件内都有效，全局变量只需在一个源文件中定义，就可以作用于所有的源文件。当然，其他不包含全局变量定义的源文件需要用extern 关键字再次声明这个全局变量。初始化为0.

普通局部变量只在定义它的函数内有效，** 初始化为随机值 **。

静态全局变量只在定义它的文件内有效，初始化为0。全局变量、文件域的静态变量和类的静态成员变量在main执行之前的静态初始化过程中分配内存并初始化

静态局部变量只在定义它的函数内有效，且程序仅分配一次内存** (局部静态变量只会定义一次,在第一次使用时分配内存并初始化) **，函数返回后，该变量不会消失；局部变量在定义它的函数内有效，但是函数返回后失效。初始化为0。

* C语言中的静态变量则是一直在编译期就初始化分配内存
#### 内存分配
全局变量，静态局部变量，静态全局变量都在静态存储区分配空间（全局区），局部变量在栈里分配空间

#### 注意点：

定义静态全局变量还有以下好处： （只在本文件作用域内有效）
1.静态全局变量不能被其它文件所用；
2.其它文件中可以定义相同名字的变量，不会发生冲突；

虽然静态局部变量看似没用，但是有函数中必须要使用static变量情况:比如当某函数的返回值为指针类型时，则必须是static的局部变量的地址作为返回值，若为auto类型，则返回为错指针。

如果我们需要一个可重入的函数，那么，我们一定要避免函数中使用static变量。（可被多个任务同时调用的就是可重入函数。）
>
不可重入函数多数满足下列条件
>
（1）函数体内使用了静态的数据结构；
（2）函数体内调用了malloc()或者free()函数；
（3）函数体内调用了标准I/O函数。
