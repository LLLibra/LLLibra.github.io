---
layout: post
title:  "C++关键词"
data: 星期四, 05. 三月 2020 02:43下午 
categories: C++
tags: 专题
---
* 该模块会针对C++中的某一块知识做专题整理，也许会有些不足或者错误的地方，未来可能会作修改。

# C++专题12----关键词

* 该篇博文用以记录C++中的一些关键字

## volatile
* 理解volatile需要对C++的内存管理有一定的理解
>
**在开始讲volatile需要明白一些概念**
>
**编译器对代码的优化**
>
所谓的编译器对代码的优化就是只要保证给我们写的代码相同的输入，代码的输出是正确，编译器就可以在这个限制下任意改写程序的逻辑。这里的输入输出包括了标准输入输出、文件系统、网络IO、甚至一些system call等等，所有程序外部的事物都包含在内。

它用来解决变量在“共享”环境下容易出现读取错误的问题。

定义为volatile的变量是说这变量可能会被意想不到地改变，即在你程序运行过程中一直会变，你希望这个值被正确的处理，**每次从内存中去读这个值**，而不是因编译器优化从缓存的地方读取，比如读取缓存在寄存器中的数值，从而保证volatile变量被正确的读取。

## mutable
mutable是为了突破const的限制而设置的

有两种使用情况（本质都是一样的）

（1）在类中修饰成员变量，因为类中的const成员函数是无法修改类中的成员变量的，但是如果用mutable修饰就可以在const成员函数中修改改成员变量了。

（2）在lambda函数中使用（可以看我的lambda博文）

## Constexpr

constexpr是C++11中新增的关键字，其语义是“常量表达式”

constexpr所修饰的变量一定是编译期可求值的

Constexpr 函数是指能用于常量表达式的函数，函数的返回类型及所有形参的类型都是字面值类型，而且函数体内必须有且只有一条return语句，一定会返回constexpr。。


#### 什么时候会同时用const和Constexpr
一般来说修饰变量时没有必要同时使用const和constexpr 因为constexpr包含了 const的含义，但是有一些特殊情况

![](https://github.com/LLLibra/LLLibra.github.io/raw/master/_posts/imgs//20200315-210417.png)

在这里constexpr和const都必须要有。constexpr表示NP指针本身是常量表达式，而const表示指向的值是一个常量。去掉const之后无法编译，因为不能用普通指针指向常量。

#### constexpr的好处：

1.是一种很强的约束，更好地保证程序的正确语义不被破坏。

2.编译器可以在编译期对constexpr的代码进行非常大的优化，比如将用到的constexpr表达式都直接替换成最终结果等。

3.相比宏来说，没有额外的开销，但更安全可靠。


## inline 、 #define 和 typedef 
 Effective C++总结1 条款2 有讲为什么要用inline代替define
#### inline函数
>
inline是指嵌入代码，在调用函数的地方不是跳转，而是把代码直接写到那里去，对于短小的函数来说，inline函数可以得到一定效率的提升,以空间换时间。

1.对内联函数进行任何修改，都需要重新编译函数的所有客户端，因为编译器需要重新更换一次所有的代码，否则将会继续使用旧的函数。

2.内联函数在编译时被替换。

3.函数内不包含for、while、switch语句,同时函数不能放在循环体里。如果inline函数体内循环会导致函数过于复杂，这是很即使你加了inline编译体也不会实现inline。

4.inline有安全类型转换，要做参数类型检查，宏没有。

5.在类体内的定义的成员函数都是内联函数，在类体外定义的成员函数则都是外联函数。（要想在体外声明又是内联，最好定义和声明的地方都加inline，但是 最后还是要看编译器）

6.一个可执行文件的cpp文件中一个函数只能被定义一次。如果你把函数定义在一个.h文件中并让两个cpp包含就会造成这个函数分别在两个cpp中被定义产生错误。但是inline函数是允许在多个cpp中多次定义的，就解决了这个问题。

7.在一个文件中定义的inline函数不能再另一个文件（指没有加头文件的文件）中使用。

#### define
在宏扩展时，只对宏名做**简单的字符替换**，不做任何计算，也不做任何语法检查

宏由编译预处理程序处理。

**define的优点：**

提高程序的运行效率：使用带参的宏定义既可完成函数调用的功能，又能避免函数的出栈与入栈操作，减少系统开销，提高运行效率，减少转场消耗；


#### typedef
定义类型别名 用于处理复杂类型

是编译时处理

####define和typedef的区别
1.处理时间不同

2.define的作用比typedef更广一些，但我们习惯用typedef来命名变量别名，用define命名常量

3.作用域不同，define没有作用域的限制，只要是之前预定义过的宏，在以后的程序中都可以使用。而typedef有自己的作用域。

4.对指针处理的不同

![](https://github.com/LLLibra/LLLibra.github.io/raw/master/_posts/imgs//20200320-091150.png)

##Override

####作用
在成员函数声明或定义中， override 确保该函数为虚函数并覆写来自基类的虚函数。主要是为了确保基类有该虚函数，如果没有该虚函数则会报错。

####用法

![](https://github.com/LLLibra/LLLibra.github.io/raw/master/_posts/imgs//20200319-130546.png)


##extern C
主要作用就是为了能够正确实现C++代码调用其他C语言代码。加上extern "C"后，会指示编译器这部分代码按C语言（而不是C++）的方式进行编译。

>
由于C、C++编译器对函数的编译处理是不完全相同的，尤其对于C++来说，支持函数的重载，编译后的函数一般是以函数名和形参类型来命名的。
>
例如函数void fun(int, int)，编译后的可能是_fun_int_int(不同编译器可能不同，但都采用了类似的机制，用函数名和参数类型来命名编译后的函数名)；而C语言没有类似的重载机制，一般是利用函数名来指明编译后的函数名的，对应上面的函数可能会是_fun这样的名字。


![](https://github.com/LLLibra/LLLibra.github.io/raw/master/_posts/imgs/20200322-152824.png)
