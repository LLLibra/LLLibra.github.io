---
layout: post
title:  "线程池"
data: 星期三, 25. 三月 2020 09:47上午 
categories: 操作系统
tags: 专题
---
* 该模块会针对操作系统中的某一块知识做专题整理，也许会有些不足或者错误的地方，未来可能会作修改。

# 操作系统专题15----线程池


## 为什么要线程池
创建线程和销毁线程的花销是比较大的，这些时间有可能比处理业务的时间还要长。这样频繁的创建线程和销毁线程，再加上业务工作线程，消耗系统资源的时间，可能导致系统资源不足。（我们可以把创建和销毁的线程的过程去掉）



## 线程池的作用
1、提高效率 创建好一定数量的线程放在池中，等需要使用的时候就从池中拿一个，这要比需要的时候创建一个线程对象要快的多。

2、方便管理 可以编写线程池管理代码对池中的线程同一进行管理，防止线程过多或者过少。


## 线程数选择
任务一般可分为：CPU密集型、IO密集型、混合型，对于不同类型的任务需要分配不同大小的线程池。

#### CPU密集型
尽量使用较小的线程池，一般为CPU核心数+1。
因为CPU密集型任务使得CPU使用率很高，若开过多的线程数，只能增加上下文切换的次数，因此会带来额外的开销。

对于计算密集型的程序，线程数应当等于核心数，但是再怎么计算密集，总有一些IO吧，所以再加一个线程来把等待IO的CPU时间利用起来。

#### IO密集型任务
可以使用稍大的线程池，一般为2*CPU核心数。

IO密集型任务CPU使用率并不高，因此可以让CPU在等待IO的时候去处理别的任务，充分利用CPU时间。

#### 混合型
可以将任务分成IO密集型和CPU密集型任务，然后分别用不同的线程池去处理。 只要分完之后两个任务的执行时间相差不大，那么就会比串行执行来的高效。 

因为如果划分之后两个任务执行时间相差甚远，那么先执行完的任务就要等后执行完的任务，最终的时间仍然取决于后执行完的任务，而且还要加上任务拆分与合并的开销，得不偿失。

## 线程池实现
我们得理一理一个简单的线程池实现的流程

#### 创建线程池类
我们会创建一个名为threadPool的类，这个就是我们需要维护的线程池，**这个类是模板类**，因为我们不知道线程需要执行的任务是什么，假设这个任务为T（可能是一个函数或者类）。

>
分析一下这个类需要哪些元素
>
1.工作队列work_q（用queue或者vector），用来存一个个线程。
>
2.任务队列task_q（用queue或者vector），用来存等待完成T
>
3.互斥量q_mutex (mutex类型)， 
>> #### unique_lock(和mutex一起用)
>>
使用原因：1.只用mutex的话，容易不小心漏写mutex.unlock()   2.如果要使用condition_variable的话，需要std::unique_lock配合
>>
unique_lock是模板类。它提供了lock()和unlock()接口，能记录现在处于上锁还是没上锁状态，在析构的时候，会根据当前状态来决定是否要进行解锁（lock_guard就一定会解锁）
>>
unique_lock对象以独占所有权的方式(**没有其他的 unique_lock 对象同时拥有某个 mutex 对象的所有权**)管理mutex对象的上锁和解锁操作，即在unique_lock对象的声明周期内，它所管理的锁对象会一直保持上锁状态（如果不操作的话）；而unique_lock的生命周期结束之后，它所管理的锁对象会被解锁。即构造函数上锁(默认是上锁的，但是可以不上)，析构函数解锁。
>
4.条件变量 condition（condition_variable）
>>
condition_variable有两个函数wait和notify，分别是等待和唤醒线程
>>
当condition_variable 对象的某个 wait 函数被调用的时候，它使用 unique_lock(通过 mutex) 来锁住当前线程。当前线程会一直被阻塞，直到另外一个线程在相同的 condition_variable 对象上调用了 notification 函数来唤醒当前线程。
>> #### wait
wait函数有两种使用方法，第一种是直接传入当前线程的锁，直到某个线程调用notify唤醒了当前线程
>>
第二种是除了锁还有在Predicate。仅仅有当 pred 条件为false 时调用 wait() 才会堵塞当前线程。而且在收到其它线程的通知后仅仅有当 pred 为 true 时才会被解除堵塞。

>> #### notify
notify_one()是唤醒一个进程
>>
notify_all() 是唤醒所有进程


#### 构造函数
构造函数为模板函数成员

传入参数为需要创建的线程数

将创建的线程放入工作队列中
> #### 线程创建函数worker
>


#### 传入任务（append）
构造函数已经创建了多个线程

我们可以通过append传入一个任务，即为任务队列添加任务

这个过程要用到q_mutex


#### 析构函数
















