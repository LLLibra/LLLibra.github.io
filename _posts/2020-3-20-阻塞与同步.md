---
layout: post
title:  "阻塞和非阻塞、同步和异步"
data: 星期五, 20. 三月 2020 09:46上午 
categories: 操作系统
tags: 专题
---
* 该模块会针对操作系统中的某一块知识做专题整理，也许会有些不足或者错误的地方，未来可能会作修改。

#  操作系统专题8----阻塞和非阻塞、同步和异步

## 阻塞与非阻塞
阻塞和非阻塞通常用来形容多线程间的相互影响。一个线程占用了临
界区资源，那么其他所有需要这个资源的线程就必须在这个临界区中进行等待
等待会导致线程挂起，这种情况就是阻塞。此时，如果占用资源的线程一直不
愿意释放资源，那么其他所有阻塞在这个临界区上的线程都不能工作。

非阻塞的意思与之相反，它强调没有一个线程可以妨碍其他线程执行，所
有的线程都会尝试不断前向执行。


## 同步与异步
 同步和异步通常用来形容一次方法调用。同步方法调用了就得等它返回，异步方法调用则可以继续其他的操作而不需要等待，之后会返回給调用者信息。



## I/O操作

**IO分两阶段（一旦拿到数据后就变成了数据操作，不再是IO）：**
 
 1.数据准备阶段

 2.内核空间复制数据到用户进程缓冲区（用户空间）阶段

同步IO和异步IO的区别在于第一步发起IO请求是否会被阻塞，异步就不需要监听数据是否到来，但是同步就需要不停监听。

阻塞IO和非阻塞IO的区别就在于第二个步骤是否阻塞，阻塞即为同步，不阻塞即为异步。非阻塞IO就是读数据的时候，不论结果如果都立即返回，但是阻塞的IO发现缓存区为空就会阻塞一直等。

**在非阻塞IO模型中，用户线程需要不断地询问内核数据是否就绪，也就说非阻塞IO不会交出CPU，而会一直占用CPU。**

![](https://github.com/LLLibra/LLLibra.github.io/raw/master/_posts/imgs/20200320-100551.png)


**只有异步IO只有非阻塞的，而同步可以阻塞可以非阻塞。**


#### 异步IO
当用户线程发起read操作之后，立刻就可以开始去做其它的事。而另一方面，从内核的角度，当它收到一个asynchronous read之后，它会立刻返回，说明read请求已经成功发起了，因此不会对用户线程产生任何block。然后，内核会等待数据准备完成，然后将数据拷贝到用户线程，当这一切都完成之后，内核会给用户线程发送一个信号，告诉它read操作完成了。也就说用户线程完全不需要知道实际的整个IO操作是如何进行的，只需要先发起一个请求，当接收内核返回的成功信号时表示IO操作已经完成，可以直接去使用数据了。

**这两个阶段都是由内核自动完成，然后发送一个信号告知用户线程操作已完成。**

#### 同步IO有哪些

1)阻塞I/O（blocking I/O）

2)非阻塞I/O （nonblocking I/O）

3) I/O复用(select 和poll) （I/O multiplexing）

4)信号驱动I/O （signal driven I/O (SIGIO)）

#### 异步IO有哪些

异步IO就是非常适合IO密集型的场景，比如网络爬虫和Web服务。

>
异步IO的通常都是非阻塞IO的，但是非阻塞IO并不一定就是异步IO，所以不存在 "异步阻塞" 的说法。另外，阻塞IO肯定也是同步IO，反之，则不一定。
>
比如 Email 的场景就是异步的，当你发送邮件后，成功与否你无法马上得到响应(比如出现 to address 不存在时)，但它此时并没有阻塞(异步非阻塞)，所以异步的本质是，当消息发送到对方没有立即得到期待的回应。 反而 HTTP 就是就是同步的，发送请求，并等待对方(server)马上得到回应，当然此时该 thread 处于阻塞的状态(同步阻塞)。

![](https://github.com/LLLibra/LLLibra.github.io/raw/master/_posts/imgs/20200404-152009.png)



#### 特殊的非阻塞同步IO

![](https://github.com/LLLibra/LLLibra.github.io/raw/master/_posts/imgs/20200404-150714.png)



## 线程与进程的同步
#### 什么是同步
所谓同步，就是在发出一个功能调用时，在没有得到结果之前，该调用就不返回，同时其它线程也不能调用这个方法。

在多线程编程里面，一些敏感数据不允许被多个线程同时访问，此时就使用同步访问技术，保证数据在任何时刻，最多有一个线程访问。 多进程也可以类推。


#### 同步的实现方式

**1.临界区(Critical Section)（线程同步）** 

只允许一个线程进入临界区，其他试图访问的线程会被挂起。其范围为单个进程内。

操作：

临界区在使用时以CRITICAL_SECTION结构对象保护共享资源，并分别用EnterCriticalSection（）和LeaveCriticalSection（）函数去标识和释放一个临界区。所用到的CRITICAL_SECTION结构对象必须经过InitializeCriticalSection（）的初始化后才能使用，而且必须确保所有线程中的任何试图访问此共享资源的代码都处在此临界区的保护之下。

![](https://github.com/LLLibra/LLLibra.github.io/raw/master/_posts/imgs/20200326-103953.png)

**2.互斥量(Mutex)**
* 属于内核对象，也可以用于进程通信

只允许拥有互斥对象的线程访问公共资源，而互斥对象只有一个。可以在不同进程间使用。临界区的范围加强版。

操作：加锁，解锁

C++中的mutex库

![](https://github.com/LLLibra/LLLibra.github.io/raw/master/_posts/imgs/20200326-104031.png)

> #### 互斥量和临界区的区别
 互斥量和临界区的作用很相似，但互斥量是能够命名的，也就是说他能够跨越进程使用。所以创建互斥量需要的资源更多，所以假如只为了在进程内部是用的话使用临界区会带来速度上的优势并能够减少资源占用量。因为互斥量是跨进程的互斥量一旦被创建，就能够通过名字打开他。 


**3.条件变量**
wait与notify

C++ 的condition_variable库

**4.读写锁**
可以多个线程同时读，但是不能多个线程同时写


**5.信号量**
是内核对象，既可以用于进程同步，也能用于线程同步

**6.信号机制**
也是用于进程间通信，用于线程同步应该也行。
